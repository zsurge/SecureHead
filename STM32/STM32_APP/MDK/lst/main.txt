; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\user -I..\dev -I..\lib\inc -I..\core_cm3 -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\main.crf ..\user\main.c]
                          THUMB

                          AREA ||i.EXTI_Configuration||, CODE, READONLY, ALIGN=2

                  EXTI_Configuration PROC
;;;172    *******************************************************************************/
;;;173    void EXTI_Configuration(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;174    {
;;;175    	GPIO_InitTypeDef GPIO_InitStructure;
;;;176    	NVIC_InitTypeDef NVIC_InitStructure;
;;;177    	EXTI_InitTypeDef EXTI_InitStructure;
;;;178    
;;;179    	//配置外部中断事件
;;;180    	/*外部中断使用PB2*/												//初始化 PB2		CPD
;;;181    	GPIO_InitStructure.GPIO_Pin	  = PinCPD;
000002  2004              MOVS     r0,#4
000004  f8ad000c          STRH     r0,[sp,#0xc]
;;;182    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000008  2003              MOVS     r0,#3
00000a  f88d000e          STRB     r0,[sp,#0xe]
;;;183    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;			//输入模式
00000e  2004              MOVS     r0,#4
000010  f88d000f          STRB     r0,[sp,#0xf]
;;;184    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000014  a903              ADD      r1,sp,#0xc
000016  4859              LDR      r0,|L1.380|
000018  f7fffffe          BL       GPIO_Init
;;;185    
;;;186    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);					//抢占式优先级别设置为无抢占优先级
00001c  f44f60e0          MOV      r0,#0x700
000020  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;187    	NVIC_InitStructure.NVIC_IRQChannel    = EXTI4_IRQn;				//指定中断源
000024  200a              MOVS     r0,#0xa
000026  f88d0008          STRB     r0,[sp,#8]
;;;188    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;		//指定响应优先级别0
00002a  2000              MOVS     r0,#0
00002c  f88d0009          STRB     r0,[sp,#9]
;;;189    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
000030  2001              MOVS     r0,#1
000032  f88d000b          STRB     r0,[sp,#0xb]
;;;190    	NVIC_Init(&NVIC_InitStructure);
000036  a802              ADD      r0,sp,#8
000038  f7fffffe          BL       NVIC_Init
;;;191    
;;;192    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource2);		//PA4作为外部中断通道
00003c  2102              MOVS     r1,#2
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       GPIO_EXTILineConfig
;;;193    	EXTI_InitStructure.EXTI_Line    = EXTI_Line2;					//外部中断通道4
000044  2004              MOVS     r0,#4
000046  9000              STR      r0,[sp,#0]
;;;194    	EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;			//外部中断模式
000048  2000              MOVS     r0,#0
00004a  f88d0004          STRB     r0,[sp,#4]
;;;195    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;	//下降沿触发
00004e  2010              MOVS     r0,#0x10
000050  f88d0005          STRB     r0,[sp,#5]
;;;196    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;						//使能
000054  2001              MOVS     r0,#1
000056  f88d0006          STRB     r0,[sp,#6]
;;;197    	EXTI_Init(&EXTI_InitStructure);
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       EXTI_Init
;;;198    
;;;199    	//配置外部中断事件
;;;200    	/*外部中断使用PA7*/											//初始化 PA7		F2F1
;;;201    	GPIO_InitStructure.GPIO_Pin	  = PinOUT1;
000060  2080              MOVS     r0,#0x80
000062  f8ad000c          STRH     r0,[sp,#0xc]
;;;202    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000066  2003              MOVS     r0,#3
000068  f88d000e          STRB     r0,[sp,#0xe]
;;;203    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;			//输入模式
00006c  2004              MOVS     r0,#4
00006e  f88d000f          STRB     r0,[sp,#0xf]
;;;204    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000072  a903              ADD      r1,sp,#0xc
000074  4842              LDR      r0,|L1.384|
000076  f7fffffe          BL       GPIO_Init
;;;205    
;;;206    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);					//抢占式优先级别设置为无抢占优先级
00007a  f44f60e0          MOV      r0,#0x700
00007e  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;207    	NVIC_InitStructure.NVIC_IRQChannel    = EXTI15_10_IRQn;			//指定中断源
000082  2028              MOVS     r0,#0x28
000084  f88d0008          STRB     r0,[sp,#8]
;;;208    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;		//指定响应优先级别0
000088  2000              MOVS     r0,#0
00008a  f88d0009          STRB     r0,[sp,#9]
;;;209    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
00008e  2001              MOVS     r0,#1
000090  f88d000b          STRB     r0,[sp,#0xb]
;;;210    	NVIC_Init(&NVIC_InitStructure);
000094  a802              ADD      r0,sp,#8
000096  f7fffffe          BL       NVIC_Init
;;;211    
;;;212    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource7);	//PA10作为外部中断通道
00009a  2107              MOVS     r1,#7
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       GPIO_EXTILineConfig
;;;213    	EXTI_InitStructure.EXTI_Line    = EXTI_Line7;					//外部中断通道10
0000a2  2080              MOVS     r0,#0x80
0000a4  9000              STR      r0,[sp,#0]
;;;214    	EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;			//外部中断模式
0000a6  2000              MOVS     r0,#0
0000a8  f88d0004          STRB     r0,[sp,#4]
;;;215    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;	//下降沿触发
0000ac  2010              MOVS     r0,#0x10
0000ae  f88d0005          STRB     r0,[sp,#5]
;;;216    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;						//使能
0000b2  2001              MOVS     r0,#1
0000b4  f88d0006          STRB     r0,[sp,#6]
;;;217    	EXTI_Init(&EXTI_InitStructure);
0000b8  4668              MOV      r0,sp
0000ba  f7fffffe          BL       EXTI_Init
;;;218    
;;;219    	//配置外部中断事件
;;;220    	/*外部中断使用PB0*/												//初始化 PB0		F2F2
;;;221    	GPIO_InitStructure.GPIO_Pin	  = PinOUT2;
0000be  2001              MOVS     r0,#1
0000c0  f8ad000c          STRH     r0,[sp,#0xc]
;;;222    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c4  2003              MOVS     r0,#3
0000c6  f88d000e          STRB     r0,[sp,#0xe]
;;;223    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;			//输入模式
0000ca  2004              MOVS     r0,#4
0000cc  f88d000f          STRB     r0,[sp,#0xf]
;;;224    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000d0  a903              ADD      r1,sp,#0xc
0000d2  482a              LDR      r0,|L1.380|
0000d4  f7fffffe          BL       GPIO_Init
;;;225    
;;;226    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);					//抢占式优先级别设置为无抢占优先级
0000d8  f44f60e0          MOV      r0,#0x700
0000dc  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;227    	NVIC_InitStructure.NVIC_IRQChannel    = EXTI0_IRQn;				//指定中断源
0000e0  2006              MOVS     r0,#6
0000e2  f88d0008          STRB     r0,[sp,#8]
;;;228    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;		//指定响应优先级别0
0000e6  2000              MOVS     r0,#0
0000e8  f88d0009          STRB     r0,[sp,#9]
;;;229    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
0000ec  2001              MOVS     r0,#1
0000ee  f88d000b          STRB     r0,[sp,#0xb]
;;;230    	NVIC_Init(&NVIC_InitStructure);
0000f2  a802              ADD      r0,sp,#8
0000f4  f7fffffe          BL       NVIC_Init
;;;231    
;;;232    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);		//PA0作为外部中断通道
0000f8  2100              MOVS     r1,#0
0000fa  2001              MOVS     r0,#1
0000fc  f7fffffe          BL       GPIO_EXTILineConfig
;;;233    	EXTI_InitStructure.EXTI_Line    = EXTI_Line0;					//外部中断通道0
000100  2001              MOVS     r0,#1
000102  9000              STR      r0,[sp,#0]
;;;234    	EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;			//外部中断模式
000104  2000              MOVS     r0,#0
000106  f88d0004          STRB     r0,[sp,#4]
;;;235    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;	//下降沿触发
00010a  2010              MOVS     r0,#0x10
00010c  f88d0005          STRB     r0,[sp,#5]
;;;236    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;						//使能
000110  2001              MOVS     r0,#1
000112  f88d0006          STRB     r0,[sp,#6]
;;;237    	EXTI_Init(&EXTI_InitStructure);
000116  4668              MOV      r0,sp
000118  f7fffffe          BL       EXTI_Init
;;;238    
;;;239    	//配置外部中断事件
;;;240    	/*外部中断使用PB4*/												//初始化 PB1		F2F3
;;;241    	GPIO_InitStructure.GPIO_Pin	  = PinOUT3;
00011c  2002              MOVS     r0,#2
00011e  f8ad000c          STRH     r0,[sp,#0xc]
;;;242    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000122  2003              MOVS     r0,#3
000124  f88d000e          STRB     r0,[sp,#0xe]
;;;243    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;			//输入模式
000128  2004              MOVS     r0,#4
00012a  f88d000f          STRB     r0,[sp,#0xf]
;;;244    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00012e  a903              ADD      r1,sp,#0xc
000130  4812              LDR      r0,|L1.380|
000132  f7fffffe          BL       GPIO_Init
;;;245    
;;;246    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);					//抢占式优先级别设置为无抢占优先级
000136  f44f60e0          MOV      r0,#0x700
00013a  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;247    	NVIC_InitStructure.NVIC_IRQChannel    = EXTI9_5_IRQn;			//指定中断源
00013e  2017              MOVS     r0,#0x17
000140  f88d0008          STRB     r0,[sp,#8]
;;;248    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;		//指定响应优先级别0
000144  2000              MOVS     r0,#0
000146  f88d0009          STRB     r0,[sp,#9]
;;;249    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
00014a  2001              MOVS     r0,#1
00014c  f88d000b          STRB     r0,[sp,#0xb]
;;;250    	NVIC_Init(&NVIC_InitStructure);
000150  a802              ADD      r0,sp,#8
000152  f7fffffe          BL       NVIC_Init
;;;251    
;;;252    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);		//PA6作为外部中断通道
000156  2101              MOVS     r1,#1
000158  4608              MOV      r0,r1
00015a  f7fffffe          BL       GPIO_EXTILineConfig
;;;253    	EXTI_InitStructure.EXTI_Line    = EXTI_Line1;					//外部中断通道6
00015e  2002              MOVS     r0,#2
000160  9000              STR      r0,[sp,#0]
;;;254    	EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;			//外部中断模式
000162  2000              MOVS     r0,#0
000164  f88d0004          STRB     r0,[sp,#4]
;;;255    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;	//下降沿触发
000168  2010              MOVS     r0,#0x10
00016a  f88d0005          STRB     r0,[sp,#5]
;;;256    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;						//使能
00016e  2001              MOVS     r0,#1
000170  f88d0006          STRB     r0,[sp,#6]
;;;257    	EXTI_Init(&EXTI_InitStructure);
000174  4668              MOV      r0,sp
000176  f7fffffe          BL       EXTI_Init
;;;258    }
00017a  bd1f              POP      {r0-r4,pc}
;;;259    
                          ENDP

                  |L1.380|
                          DCD      0x40010c00
                  |L1.384|
                          DCD      0x40010800

                          AREA ||i.IWDG_Configuration||, CODE, READONLY, ALIGN=1

                  IWDG_Configuration PROC
;;;327    #define DEV_WDG_RELOAD  1000   					//喂狗时间
;;;328    void IWDG_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330    	/* 写入0x5555,用于允许狗狗寄存器写入功能 */
;;;331    	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
000002  f2455055          MOV      r0,#0x5555
000006  f7fffffe          BL       IWDG_WriteAccessCmd
;;;332     
;;;333    	/* 狗狗时钟分频, 40K / 64 = 625HZ (1.6ms)*/
;;;334    	IWDG_SetPrescaler(DEV_WDG_PR);
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       IWDG_SetPrescaler
;;;335     
;;;336    	/* 喂狗时间 1.6s / 1.6MS = 1000 .注意不能大于0xfff*/
;;;337    	IWDG_SetReload(DEV_WDG_RELOAD);
000010  f44f707a          MOV      r0,#0x3e8
000014  f7fffffe          BL       IWDG_SetReload
;;;338     
;;;339    	/* 喂狗*/
;;;340    	IWDG_ReloadCounter();
000018  f7fffffe          BL       IWDG_ReloadCounter
;;;341     
;;;342    	/* 使能狗狗*/
;;;343    	IWDG_Enable();
00001c  f7fffffe          BL       IWDG_Enable
;;;344    }
000020  bd10              POP      {r4,pc}
;;;345    
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;94     *******************************************************************************/
;;;95     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97     	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0);
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;98     }
00000c  bd10              POP      {r4,pc}
;;;99     
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;40     *******************************************************************************/
;;;41     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;42     {
;;;43     	//将外设 RCC寄存器重设为缺省值
;;;44     	RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;45     
;;;46     	//使能内部晶振，内部晶振频率8MHz
;;;47     	RCC_HSICmd(ENABLE);
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       RCC_HSICmd
;;;48       
;;;49     	//等待HSI晶振就绪
;;;50     	while(RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
00000c  bf00              NOP      
                  |L4.14|
00000e  2021              MOVS     r0,#0x21
000010  f7fffffe          BL       RCC_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0fa              BEQ      |L4.14|
;;;51     	
;;;52     	//开启FLASH预取指功能
;;;53     	FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;54     	
;;;55     	//FLASH时序控制
;;;56     	FLASH_SetLatency(FLASH_Latency_2);
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       FLASH_SetLatency
;;;57        
;;;58     	//设置HCLK（AHB时钟）=SYSCLK
;;;59     	RCC_HCLKConfig(RCC_SYSCLK_Div1);
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_HCLKConfig
;;;60        
;;;61     	//PCLK2(APB2) = HCLK
;;;62     	RCC_PCLK2Config(RCC_HCLK_Div1);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_PCLK2Config
;;;63       
;;;64     	//PCLK1(APB1) = HCLK/2
;;;65     	RCC_PCLK1Config(RCC_HCLK_Div2);
000030  f44f6080          MOV      r0,#0x400
000034  f7fffffe          BL       RCC_PCLK1Config
;;;66         
;;;67     	//设置PLL时钟源及倍频系数:8M * 9 = 72MHz
;;;68     	RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_9);   
000038  f44f11e0          MOV      r1,#0x1c0000
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       RCC_PLLConfig
;;;69                     
;;;70     	//使能PLL
;;;71     	RCC_PLLCmd(ENABLE);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       RCC_PLLCmd
;;;72     
;;;73     	//等待指定的 RCC 标志位设置成功 等待PLL初始化成功
;;;74     	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);	
000048  bf00              NOP      
                  |L4.74|
00004a  2039              MOVS     r0,#0x39
00004c  f7fffffe          BL       RCC_GetFlagStatus
000050  2800              CMP      r0,#0
000052  d0fa              BEQ      |L4.74|
;;;75     
;;;76     	//设置系统时钟（SYSCLK） 设置PLL为系统时钟源
;;;77     	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000054  2002              MOVS     r0,#2
000056  f7fffffe          BL       RCC_SYSCLKConfig
;;;78       
;;;79     	//等待PLL成功用作于系统时钟的时钟源
;;;80     	//  0x00：HSI 作为系统时钟 
;;;81     	//  0x04：HSE作为系统时钟 
;;;82     	//  0x08：PLL作为系统时钟  
;;;83     	while(RCC_GetSYSCLKSource() != 0x08);	
00005a  bf00              NOP      
                  |L4.92|
00005c  f7fffffe          BL       RCC_GetSYSCLKSource
000060  2808              CMP      r0,#8
000062  d1fb              BNE      |L4.92|
;;;84     }
000064  bd10              POP      {r4,pc}
;;;85     
                          ENDP


                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=1

                  RTC_Configuration PROC
;;;268    *******************************************************************************/
;;;269    void RTC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;270    {
;;;271    	NVIC_InitTypeDef NVIC_InitStructure;
;;;272    
;;;273    	/* Allow access to BKP Domain */
;;;274    	PWR_BackupAccessCmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       PWR_BackupAccessCmd
;;;275    	
;;;276    	/* Reset Backup Domain */
;;;277    	BKP_DeInit();
000008  f7fffffe          BL       BKP_DeInit
;;;278    	
;;;279    	/* Enable LSI OSC */
;;;280    	RCC_LSICmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_LSICmd
;;;281    
;;;282    	/* Wait till LSI is ready */
;;;283    	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
000012  bf00              NOP      
                  |L5.20|
000014  2061              MOVS     r0,#0x61
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2800              CMP      r0,#0
00001c  d0fa              BEQ      |L5.20|
;;;284    	{}
;;;285    	
;;;286    	/* Select LSI as RTC Clock Source */
;;;287    	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
00001e  f44f7000          MOV      r0,#0x200
000022  f7fffffe          BL       RCC_RTCCLKConfig
;;;288    	
;;;289    	/* Enable RTC Clock */
;;;290    	RCC_RTCCLKCmd(ENABLE);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       RCC_RTCCLKCmd
;;;291    	
;;;292    	/* Wait for RTC registers synchronization */
;;;293    	RTC_WaitForSynchro();
00002c  f7fffffe          BL       RTC_WaitForSynchro
;;;294    
;;;295    	/* Set the RTC time base to 1s */
;;;296    	RTC_SetPrescaler(40000); 
000030  f6494040          MOV      r0,#0x9c40
000034  f7fffffe          BL       RTC_SetPrescaler
;;;297    	
;;;298    	/* Wait until last write operation on RTC registers has finished */
;;;299    	RTC_WaitForLastTask();
000038  f7fffffe          BL       RTC_WaitForLastTask
;;;300    	
;;;301    	/* Enable the RTC Alarm interrupt */
;;;302    	RTC_ITConfig(RTC_IT_ALR, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RTC_ITConfig
;;;303    
;;;304    	/* Wait until last write operation on RTC registers has finished */
;;;305    	RTC_WaitForLastTask();
000044  f7fffffe          BL       RTC_WaitForLastTask
;;;306    	  
;;;307    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000048  f44f60a0          MOV      r0,#0x500
00004c  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;308    	  
;;;309    	/* Enable the RTCAlarm_IRQn Interrupt */
;;;310    	NVIC_InitStructure.NVIC_IRQChannel = RTCAlarm_IRQn;
000050  2029              MOVS     r0,#0x29
000052  f88d0000          STRB     r0,[sp,#0]
;;;311    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000056  2000              MOVS     r0,#0
000058  f88d0001          STRB     r0,[sp,#1]
;;;312    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00005c  f88d0002          STRB     r0,[sp,#2]
;;;313    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000060  2001              MOVS     r0,#1
000062  f88d0003          STRB     r0,[sp,#3]
;;;314    	NVIC_Init(&NVIC_InitStructure);
000066  4668              MOV      r0,sp
000068  f7fffffe          BL       NVIC_Init
;;;315    }
00006c  bd08              POP      {r3,pc}
;;;316    
                          ENDP


                          AREA ||i.SYSCLKConfig_STOP||, CODE, READONLY, ALIGN=1

                  SYSCLKConfig_STOP PROC
;;;355    *******************************************************************************/
;;;356    void SYSCLKConfig_STOP(void)
000000  b510              PUSH     {r4,lr}
;;;357    {
;;;358    	//使能内部晶振，内部晶振频率8MHz
;;;359    	RCC_HSICmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RCC_HSICmd
;;;360      
;;;361    	//等待HSI晶振就绪
;;;362    	while(RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
000008  bf00              NOP      
                  |L6.10|
00000a  2021              MOVS     r0,#0x21
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0fa              BEQ      |L6.10|
;;;363    	
;;;364    	//使能PLL
;;;365    	RCC_PLLCmd(ENABLE);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_PLLCmd
;;;366    
;;;367    	//等待指定的 RCC 标志位设置成功 等待PLL初始化成功
;;;368    	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);	
00001a  bf00              NOP      
                  |L6.28|
00001c  2039              MOVS     r0,#0x39
00001e  f7fffffe          BL       RCC_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0fa              BEQ      |L6.28|
;;;369    
;;;370    	//设置系统时钟（SYSCLK） 设置PLL为系统时钟源
;;;371    	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       RCC_SYSCLKConfig
;;;372      
;;;373    	//等待PLL成功用作于系统时钟的时钟源
;;;374    	//  0x00：HSI 作为系统时钟 
;;;375    	//  0x04：HSE作为系统时钟 
;;;376    	//  0x08：PLL作为系统时钟  
;;;377    	while(RCC_GetSYSCLKSource() != 0x08);
00002c  bf00              NOP      
                  |L6.46|
00002e  f7fffffe          BL       RCC_GetSYSCLKSource
000032  2808              CMP      r0,#8
000034  d1fb              BNE      |L6.46|
;;;378    }
000036  bd10              POP      {r4,pc}
;;;379    
                          ENDP


                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;110    *******************************************************************************/
;;;111    void delay_init(u8 SYSCLK)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;112    {
;;;113    	SysTick->CTRL &= 0xfffffffb;//选择内部时钟 HCLK/8
000004  6909              LDR      r1,[r1,#0x10]
000006  f0210104          BIC      r1,r1,#4
00000a  f04f22e0          MOV      r2,#0xe000e000
00000e  6111              STR      r1,[r2,#0x10]
;;;114    	fac_us = SYSCLK / 8;      
000010  17c2              ASRS     r2,r0,#31
000012  eb007252          ADD      r2,r0,r2,LSR #29
000016  f3c202c7          UBFX     r2,r2,#3,#8
00001a  4b07              LDR      r3,|L7.56|
00001c  701a              STRB     r2,[r3,#0]
;;;115    	fac_ms = fac_us * 1000;
00001e  4619              MOV      r1,r3
000020  7809              LDRB     r1,[r1,#0]  ; fac_us
000022  eb010241          ADD      r2,r1,r1,LSL #1
000026  ebc211c1          RSB      r1,r2,r1,LSL #7
00002a  f64f72ff          MOV      r2,#0xffff
00002e  ea0201c1          AND      r1,r2,r1,LSL #3
000032  4a02              LDR      r2,|L7.60|
000034  8011              STRH     r1,[r2,#0]
;;;116    }            
000036  4770              BX       lr
;;;117    
                          ENDP

                  |L7.56|
                          DCD      fac_us
                  |L7.60|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;126    *******************************************************************************/
;;;127    void delay_ms(uint16_t nms)
000000  4601              MOV      r1,r0
;;;128    {         
;;;129    	uint32_t temp;     
;;;130    	SysTick->LOAD = nms * fac_ms;				//时间加载
000002  4a0d              LDR      r2,|L8.56|
000004  8812              LDRH     r2,[r2,#0]  ; fac_ms
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;131    	SysTick->VAL  = 0x00;						//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;132    	SysTick->CTRL = 0x01;						//开始倒数  
000012  2201              MOVS     r2,#1
000014  611a              STR      r2,[r3,#0x10]
;;;133    	do {
000016  bf00              NOP      
                  |L8.24|
;;;134    		temp=SysTick->CTRL;
000018  f04f22e0          MOV      r2,#0xe000e000
00001c  6910              LDR      r0,[r2,#0x10]
;;;135    	}
;;;136    	while(temp & 0x01 && !(temp & (1 << 16)));	//等待时间到达   
00001e  f0100f01          TST      r0,#1
000022  d002              BEQ      |L8.42|
000024  f4103f80          TST      r0,#0x10000
000028  d0f6              BEQ      |L8.24|
                  |L8.42|
;;;137    	SysTick->CTRL = 0x00;       				//关闭计数器
00002a  2200              MOVS     r2,#0
00002c  f04f23e0          MOV      r3,#0xe000e000
000030  611a              STR      r2,[r3,#0x10]
;;;138    	SysTick->VAL  = 0X00;       				//清空计数器        
000032  619a              STR      r2,[r3,#0x18]
;;;139    }
000034  4770              BX       lr
;;;140     
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      fac_ms

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;149    *******************************************************************************/
;;;150    void delay_us(uint32_t Nus)
000000  4601              MOV      r1,r0
;;;151    {  
;;;152    	uint32_t temp;       
;;;153    	SysTick->LOAD = Nus * fac_us;				//时间加载      
000002  4a0d              LDR      r2,|L9.56|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;154    	SysTick->VAL  = 0x00;						//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;155    	SysTick->CTRL = 0x01;						//开始倒数   
000012  2201              MOVS     r2,#1
000014  611a              STR      r2,[r3,#0x10]
;;;156    	do {
000016  bf00              NOP      
                  |L9.24|
;;;157    		temp = SysTick->CTRL;
000018  f04f22e0          MOV      r2,#0xe000e000
00001c  6910              LDR      r0,[r2,#0x10]
;;;158    	}
;;;159    	while(temp & 0x01 && !(temp & (1 << 16)));	//等待时间到达   
00001e  f0100f01          TST      r0,#1
000022  d002              BEQ      |L9.42|
000024  f4103f80          TST      r0,#0x10000
000028  d0f6              BEQ      |L9.24|
                  |L9.42|
;;;160    	SysTick->CTRL = 0x00;       				//关闭计数器
00002a  2200              MOVS     r2,#0
00002c  f04f23e0          MOV      r3,#0xe000e000
000030  611a              STR      r2,[r3,#0x10]
;;;161    	SysTick->VAL  = 0X00;       				//清空计数器     
000032  619a              STR      r2,[r3,#0x18]
;;;162    }
000034  4770              BX       lr
;;;163    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      fac_us

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;392    extern __IO uint8_t TM3CaptureNumber;
;;;393    int main(void)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395    	int ret;
;;;396    	uint8_t Buf[110];
;;;397    	#if 0
;;;398    	RCC_Configuration();
;;;399    	
;;;400    	
;;;401    	/* Configure EXTI Line to generate an interrupt on falling edge */
;;;402    	EXTI_Configuration();
;;;403    
;;;404    	/* NVIC configuration */
;;;405    	NVIC_Configuration();
;;;406        
;;;407    	IWDG_Configuration();
;;;408    
;;;409    	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET) {			//如果上次是看门狗引起的复位
;;;410    		RCC_ClearFlag();
;;;411    	}
;;;412        
;;;413    	
;;;414    	delay_init(72);
;;;415    
;;;416    	#endif
;;;417    
;;;418    	//打开串口
;;;419    	dev_com_open();		
000002  f7fffffe          BL       dev_com_open
;;;420    	uart_puts("APP Start...\r\n");
000006  a002              ADR      r0,|L10.16|
000008  f7fffffe          BL       uart_puts
;;;421    	
;;;422    #if 0	
;;;423    	//打开定时器计时
;;;424    	TIM2_Cap_Init(72 - 1);										//以 1Mhz 的频率计数
;;;425    	TIM3_Cnt_Init();											//定时1.3s初始化，用于刷卡完成
;;;426    
;;;427    	//复位加密磁头加密KEY
;;;428    	#ifdef FLASHKEY_SUPPORT
;;;429    	if(!ReadENCKEY())
;;;430    	{
;;;431    		memset(ENC_KEY.key, 0x00, sizeof(ENC_KEY.key));
;;;432    		ENC_KEY.temp.level = 0x31;
;;;433    		WriteFlag = 1;	
;;;434    	}
;;;435    	#else
;;;436    	memset(ENC_KEY.key, 0x00, sizeof(ENC_KEY.key));
;;;437    	ENC_KEY.temp.level = 0x31;
;;;438    	#endif
;;;439    
;;;440    	while (1) {													/* main loop */
;;;441    
;;;442    		//喂狗
;;;443    		IWDG_ReloadCounter();
;;;444    		
;;;445    		//串口协议数据处理
;;;446    		DealSerialParse();
;;;447    		DealRxData();
;;;448    		
;;;449    		if (1 == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_4) && MSR_fCardDataReady) {
;;;450    
;;;451    			ret = MSR_GetCharacterDataOn(0, Buf, sizeof(Buf));	//一磁道解码
;;;452    
;;;453    //			if (0 == ret) {	
;;;454    //				printf("TK1:%s\r\n", (char *)Buf);
;;;455    //			} else {
;;;456    //				printf("TK1 ret:%d\r\n", ret);
;;;457    //			}
;;;458    
;;;459    			ret = MSR_GetCharacterDataOn(1, Buf, sizeof(Buf));	//二磁道解码
;;;460    
;;;461    //			if (0 == ret) {	
;;;462    //				printf("TK2:%s\r\n", (char *)Buf);
;;;463    //			} else {
;;;464    //				printf("TK2 ret:%d\r\n", ret);
;;;465    //			}
;;;466    
;;;467    			ret = MSR_GetCharacterDataOn(2, Buf, sizeof(Buf));	//三磁道解码
;;;468    
;;;469    //			if (0 == ret) {	
;;;470    //				printf("TK3:%s\r\n", (char *)Buf);
;;;471    //			} else {
;;;472    //				printf("TK3 ret:%d\r\n", ret);
;;;473    //			}
;;;474    			
;;;475    			MSR_SendData();
;;;476    			if (GetNextFlag) {									//计算下一个KSN
;;;477    			
;;;478    				GetNextKSN();
;;;479    				GetNextFlag = 0;
;;;480    			}
;;;481    
;;;482    			//重新初始化
;;;483    			FlushBuffer_Init();
;;;484    			TM1CaptureNumber = 0;
;;;485    			TM2CaptureNumber = 0;
;;;486    			TM3CaptureNumber = 0;
;;;487    		}
;;;488    	}
;;;489    	#endif
;;;490    
;;;491    }
00000c  2000              MOVS     r0,#0
00000e  bd10              POP      {r4,pc}
;;;492    
                          ENDP

                  |L10.16|
000010  41505020          DCB      "APP Start...\r\n",0
000014  53746172
000018  742e2e2e
00001c  0d0a00  
00001f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=1

                  base64digits
000000  41424344          DCB      0x41,0x42,0x43,0x44
000004  45464748          DCB      0x45,0x46,0x47,0x48
000008  494a4b4c          DCB      0x49,0x4a,0x4b,0x4c
00000c  4d4e4f50          DCB      0x4d,0x4e,0x4f,0x50
000010  51525354          DCB      0x51,0x52,0x53,0x54
000014  55565758          DCB      0x55,0x56,0x57,0x58
000018  595a6162          DCB      0x59,0x5a,0x61,0x62
00001c  63646566          DCB      0x63,0x64,0x65,0x66
000020  6768696a          DCB      0x67,0x68,0x69,0x6a
000024  6b6c6d6e          DCB      0x6b,0x6c,0x6d,0x6e
000028  6f707172          DCB      0x6f,0x70,0x71,0x72
00002c  73747576          DCB      0x73,0x74,0x75,0x76
000030  7778797a          DCB      0x77,0x78,0x79,0x7a
000034  30313233          DCB      0x30,0x31,0x32,0x33
000038  34353637          DCB      0x34,0x35,0x36,0x37
00003c  38392b2f          DCB      0x38,0x39,0x2b,0x2f
000040  00                DCB      0x00
                  base64val
000041  ffffff            DCB      0xff,0xff,0xff
000044  ffffffff          DCB      0xff,0xff,0xff,0xff
000048  ffffffff          DCB      0xff,0xff,0xff,0xff
00004c  ffffffff          DCB      0xff,0xff,0xff,0xff
000050  ffffffff          DCB      0xff,0xff,0xff,0xff
000054  ffffffff          DCB      0xff,0xff,0xff,0xff
000058  ffffffff          DCB      0xff,0xff,0xff,0xff
00005c  ffffffff          DCB      0xff,0xff,0xff,0xff
000060  ffffffff          DCB      0xff,0xff,0xff,0xff
000064  ffffffff          DCB      0xff,0xff,0xff,0xff
000068  ffffffff          DCB      0xff,0xff,0xff,0xff
00006c  3effffff          DCB      0x3e,0xff,0xff,0xff
000070  3f343536          DCB      0x3f,0x34,0x35,0x36
000074  3738393a          DCB      0x37,0x38,0x39,0x3a
000078  3b3c3dff          DCB      0x3b,0x3c,0x3d,0xff
00007c  ffffffff          DCB      0xff,0xff,0xff,0xff
000080  ffff0001          DCB      0xff,0xff,0x00,0x01
000084  02030405          DCB      0x02,0x03,0x04,0x05
000088  06070809          DCB      0x06,0x07,0x08,0x09
00008c  0a0b0c0d          DCB      0x0a,0x0b,0x0c,0x0d
000090  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000094  12131415          DCB      0x12,0x13,0x14,0x15
000098  16171819          DCB      0x16,0x17,0x18,0x19
00009c  ffffffff          DCB      0xff,0xff,0xff,0xff
0000a0  ffff1a1b          DCB      0xff,0xff,0x1a,0x1b
0000a4  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
0000a8  20212223          DCB      0x20,0x21,0x22,0x23
0000ac  24252627          DCB      0x24,0x25,0x26,0x27
0000b0  28292a2b          DCB      0x28,0x29,0x2a,0x2b
0000b4  2c2d2e2f          DCB      0x2c,0x2d,0x2e,0x2f
0000b8  30313233          DCB      0x30,0x31,0x32,0x33
0000bc  ffffffff          DCB      0xff,0xff,0xff,0xff
0000c0  ff                DCB      0xff
                  fac_us
0000c1  00                DCB      0x00
                  fac_ms
0000c2  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\user\\main.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_e3831934____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_e3831934____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_e3831934____REVSH|
#line 144
|__asm___6_main_c_e3831934____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
