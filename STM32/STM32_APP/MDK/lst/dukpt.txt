; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dukpt.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dukpt.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\user -I..\dev -I..\lib\inc -I..\core_cm3 -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\dukpt.crf ..\user\dukpt.c]
                          THUMB

                          AREA ||i.IDT_CalcLRC||, CODE, READONLY, ALIGN=2

                  IDT_CalcLRC PROC
;;;316    //-----------------------------------------------------------------------------
;;;317    uint8_t IDT_CalcLRC(uint8_t *key)
000000  4601              MOV      r1,r0
;;;318    {
;;;319        uint32_t     i;
;;;320        uint8_t   aLRC;
;;;321    
;;;322        aLRC = *key;                                // set LRC to 1st byte of key
000002  7808              LDRB     r0,[r1,#0]
;;;323        key++;                                      // increment key
000004  1c49              ADDS     r1,r1,#1
;;;324        for (i = 0; i < (gkeysize) - 1; i++, key++)
000006  2200              MOVS     r2,#0
000008  e003              B        |L1.18|
                  |L1.10|
;;;325        {
;;;326            aLRC ^= *key;                           // XOR key with LRC
00000a  780b              LDRB     r3,[r1,#0]
00000c  4058              EORS     r0,r0,r3
00000e  1c52              ADDS     r2,r2,#1              ;324
000010  1c49              ADDS     r1,r1,#1              ;324
                  |L1.18|
000012  4b03              LDR      r3,|L1.32|
000014  781b              LDRB     r3,[r3,#0]            ;324  ; gkeysize
000016  1e5b              SUBS     r3,r3,#1              ;324
000018  4293              CMP      r3,r2                 ;324
00001a  d8f6              BHI      |L1.10|
;;;327        }
;;;328        return aLRC;
;;;329    }
00001c  4770              BX       lr
;;;330    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      gkeysize

                          AREA ||i.IDT_ChangeCounter||, CODE, READONLY, ALIGN=1

                  IDT_ChangeCounter PROC
;;;367    //-----------------------------------------------------------------------------
;;;368    unsigned int IDT_ChangeCounter(uint32_t encCntr, uint8_t onebit)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  460b              MOV      r3,r1
;;;370        uint8_t    i, numOfOnes = 0;
000004  2500              MOVS     r5,#0
;;;371        uint32_t   mask, tmp_mask;
;;;372    
;;;373        // For each bit in encryption counter
;;;374        for (i = 0, mask = 0x100000, tmp_mask = 0x100000; (numOfOnes < onebit)&&(i < 21); i++)
000006  2100              MOVS     r1,#0
000008  f44f1280          MOV      r2,#0x100000
00000c  4614              MOV      r4,r2
00000e  e008              B        |L2.34|
                  |L2.16|
;;;375        {
;;;376    		if(i!=0)
000010  b109              CBZ      r1,|L2.22|
;;;377    		{
;;;378                mask >>= 1;
000012  0852              LSRS     r2,r2,#1
;;;379    	    	tmp_mask += mask;
000014  4414              ADD      r4,r4,r2
                  |L2.22|
;;;380    		}
;;;381            if (encCntr & mask)
000016  4210              TST      r0,r2
000018  d001              BEQ      |L2.30|
;;;382                numOfOnes++;	
00001a  1c6e              ADDS     r6,r5,#1
00001c  b2f5              UXTB     r5,r6
                  |L2.30|
00001e  1c4e              ADDS     r6,r1,#1              ;374
000020  b2f1              UXTB     r1,r6                 ;374
                  |L2.34|
000022  429d              CMP      r5,r3                 ;374
000024  da01              BGE      |L2.42|
000026  2915              CMP      r1,#0x15              ;374
000028  dbf2              BLT      |L2.16|
                  |L2.42|
;;;383        }
;;;384    
;;;385    	encCntr &= tmp_mask;
00002a  4020              ANDS     r0,r0,r4
;;;386    
;;;387        return(encCntr);
;;;388    }
00002c  bd70              POP      {r4-r6,pc}
;;;389    //-----------------------------------------------------------------------------
                          ENDP


                          AREA ||i.IDT_EncryptPIN||, CODE, READONLY, ALIGN=2

                  IDT_EncryptPIN PROC
;;;101    //-----------------------------------------------------------------------------
;;;102    int IDT_EncryptPIN(uint8_t EncryptType,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;103    							  uint32_t encrypt_counter,
;;;104                    uint8_t *pCurrKSN,            // returns the 10-byte KSN
;;;105                    uint8_t *pCurrKey,			  		// returns encrypted PIN, 16 hex digits
;;;106    				uint8_t PinKey)			      // returns encrypted PIN, 16 hex digits
;;;107    {
000004  b089              SUB      sp,sp,#0x24
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  461c              MOV      r4,r3
00000c  f8dda058          LDR      r10,[sp,#0x58]
;;;108        int   position;                   // position of right most set bit
;;;109        int   currKeyPtr;                 // current key pointer
;;;110        uint32_t   shiftReg = 0;               // shift register: 21-bit reg, whose bits are
000010  f04f0b00          MOV      r11,#0
;;;111                                            // numbered left to right as #1 to #21.
;;;112    
;;;113        //uint8_t   currKey[SIZE_3DES_KEY];     // current key used to encrypt
;;;114        uint8_t   cryptoReg[SIZE_PIN_BLK] = {0};    // crypto register
000014  2000              MOVS     r0,#0
000016  9005              STR      r0,[sp,#0x14]
000018  9006              STR      r0,[sp,#0x18]
00001a  9007              STR      r0,[sp,#0x1c]
00001c  9008              STR      r0,[sp,#0x20]
;;;115    
;;;116        if (dukpt_key->encrypt_ctr > MAX_EC)
00001e  4856              LDR      r0,|L3.376|
000020  6840              LDR      r0,[r0,#4]  ; Track3TimeFlow
000022  f5b01f00          CMP      r0,#0x200000
000026  d904              BLS      |L3.50|
;;;117            return(DUKPT_ERR_UNINITIALIZED);
000028  f06f0006          MVN      r0,#6
                  |L3.44|
;;;118    
;;;119        //Copy pinblock into crypto reg
;;;120        //memcpy(cryptoReg, pPinBlock, SIZE_CRYP_REG);
;;;121    
;;;122        // Get a valid key
;;;123        while (TRUE)
;;;124        // While LRC of current key is not valid
;;;125        {
;;;126        
;;;127            // Find position of right most set bit in encryption counter
;;;128            position = IDT_GetSetBitPos(encrypt_counter);
;;;129            // set the corresponding bit in shift reg
;;;130            shiftReg = IDT_SetBit(shiftReg, position);
;;;131        
;;;132            // set current key pointer
;;;133            currKeyPtr = position;
;;;134            // Get key pointed by the current key pointer
;;;135            memcpy (pCurrKey, dukpt_key->future_key_reg[currKeyPtr], gkeysize);
;;;136            // Check if LRC key valid
;;;137            if (dukpt_key->future_key_reg[currKeyPtr][gLRC] == IDT_CalcLRC(pCurrKey))
;;;138                // OK, we've found a valid key
;;;139                break;
;;;140            else
;;;141            {
;;;142                // Nope, add shift reg to encryption counter and continue
;;;143                dukpt_key->encrypt_ctr += shiftReg;
;;;144            }
;;;145        }
;;;146    
;;;147    	dukpt_key->encrypt_ctr = encrypt_counter;
;;;148    
;;;149        // Update counter in key serial num
;;;150        IDT_UpdateKSN(dukpt_key->encrypt_ctr, dukpt_key->initKSN);
;;;151    
;;;152    	if(PinKey == 1)
;;;153    	{
;;;154    		if (EncryptType) 
;;;155    		{
;;;156    			 // Now produce a variant of the key by XORing the
;;;157    			 // key with 0000 0000 0000 00FF 0000 0000 0000 00FF
;;;158    			 pCurrKey[SIZE_3DES_KEY - 1] ^= 0xFF;
;;;159    			 pCurrKey[(SIZE_3DES_KEY / 2) - 1] ^= 0xFF;
;;;160    		}
;;;161    		else 
;;;162    		{
;;;163    				pCurrKey[SIZE_DES_KEY-1] ^= 0xFF;
;;;164    		}
;;;165    	}
;;;166    
;;;167    
;;;168    	else if(PinKey == 0) // Data Key
;;;169    	{
;;;170    	   uint8_t key[SIZE_3DES_KEY]; 
;;;171    	   uint8_t i;
;;;172    		if (EncryptType)
;;;173    		{ // If 1, TDES
;;;174    			 // Now produce a variant of the key by XORing the key with 0000 0000 00FF 0000 0000 0000 00FF 0000
;;;175    			 pCurrKey[SIZE_3DES_KEY - 3] ^= 0xFF;
;;;176    			 pCurrKey[(SIZE_3DES_KEY >> 1) - 3] ^= 0xFF;
;;;177    			 for(i = 0; i < SIZE_3DES_KEY; i++)
;;;178    				 key[i] = pCurrKey[i];
;;;179    			
;;;180    			 tri_des(pCurrKey,key,key+8,0);
;;;181    			 tri_des(pCurrKey+8,key,key+8,0);
;;;182    		}
;;;183    		else
;;;184    		{ // If 0, Single DES
;;;185    			pCurrKey[SIZE_DES_KEY - 3] ^= 0xFF; // Only 8 bits
;;;186    			for(i = 0; i < SIZE_DES_KEY; i++)
;;;187    				key[i] = pCurrKey[i];
;;;188            
;;;189    			des(pCurrKey, key,0);   //single encryption
;;;190    		}
;;;191    	}
;;;192    
;;;193    	else if(PinKey == 2) // MAC
;;;194    	{
;;;195    		if (EncryptType) 
;;;196    		{
;;;197    			 // Now produce a variant of the key by XORing the
;;;198    			 // key with 0000 0000 0000 00FF 0000 0000 0000 00FF
;;;199    			 pCurrKey[SIZE_3DES_KEY - 2] ^= 0xFF;
;;;200    			 pCurrKey[(SIZE_3DES_KEY / 2) - 2] ^= 0xFF;
;;;201    		}
;;;202    		else 
;;;203    		{
;;;204    				pCurrKey[SIZE_DES_KEY-2] ^= 0xFF;
;;;205    		}
;;;206    	}
;;;207    
;;;208        // Return the current KSN
;;;209        memcpy(pCurrKSN, dukpt_key->initKSN, SIZE_KSN_REG);
;;;210        // Return the encrypted ciphor test PIN
;;;211        //memcpy(pCiphorPin, cryptoReg, SIZE_CRYP_REG);
;;;212    
;;;213        // Generate new future keys and delete current encrypt key
;;;214        IDT_GenNewKeys(cryptoReg, shiftReg, currKeyPtr);
;;;215    //    dukpt_key = init_dukpt_key();
;;;216    //    save_dukpt_key(dukpt_key);
;;;217    
;;;218        return(DUKPT_SUCCESS);
;;;219    }
00002c  b00d              ADD      sp,sp,#0x34
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.50|
000032  e027              B        |L3.132|
                  |L3.52|
000034  4648              MOV      r0,r9                 ;128
000036  f7fffffe          BL       IDT_GetSetBitPos
00003a  4606              MOV      r6,r0                 ;128
00003c  4631              MOV      r1,r6                 ;130
00003e  4658              MOV      r0,r11                ;130
000040  f7fffffe          BL       IDT_SetBit
000044  4683              MOV      r11,r0                ;130
000046  4637              MOV      r7,r6                 ;133
000048  463e              MOV      r6,r7                 ;135
00004a  eb071206          ADD      r2,r7,r6,LSL #4       ;135
00004e  484a              LDR      r0,|L3.376|
000050  3008              ADDS     r0,r0,#8              ;135
000052  1811              ADDS     r1,r2,r0              ;135
000054  4849              LDR      r0,|L3.380|
000056  7802              LDRB     r2,[r0,#0]            ;135  ; gkeysize
000058  4620              MOV      r0,r4                 ;135
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  4620              MOV      r0,r4                 ;137
000060  f7fffffe          BL       IDT_CalcLRC
000064  eb071206          ADD      r2,r7,r6,LSL #4       ;137
000068  4943              LDR      r1,|L3.376|
00006a  3108              ADDS     r1,r1,#8              ;137
00006c  4411              ADD      r1,r1,r2              ;137
00006e  4a44              LDR      r2,|L3.384|
000070  7812              LDRB     r2,[r2,#0]            ;137  ; gLRC
000072  5c89              LDRB     r1,[r1,r2]            ;137
000074  4288              CMP      r0,r1                 ;137
000076  d100              BNE      |L3.122|
000078  e005              B        |L3.134|
                  |L3.122|
00007a  483f              LDR      r0,|L3.376|
00007c  6840              LDR      r0,[r0,#4]            ;143  ; Track3TimeFlow
00007e  4458              ADD      r0,r0,r11             ;143
000080  493d              LDR      r1,|L3.376|
000082  6048              STR      r0,[r1,#4]            ;143  ; Track3TimeFlow
                  |L3.132|
000084  e7d6              B        |L3.52|
                  |L3.134|
000086  bf00              NOP                            ;139
000088  483b              LDR      r0,|L3.376|
00008a  f8c09004          STR      r9,[r0,#4]            ;147  ; Track3TimeFlow
00008e  4601              MOV      r1,r0                 ;150
000090  6848              LDR      r0,[r1,#4]            ;150  ; Track3TimeFlow
000092  f201116d          ADD      r1,r1,#0x16d          ;150
000096  f7fffffe          BL       IDT_UpdateKSN
00009a  f1ba0f01          CMP      r10,#1                ;152
00009e  d110              BNE      |L3.194|
0000a0  f1b80f00          CMP      r8,#0                 ;154
0000a4  d008              BEQ      |L3.184|
0000a6  7be0              LDRB     r0,[r4,#0xf]          ;158
0000a8  f08000ff          EOR      r0,r0,#0xff           ;158
0000ac  73e0              STRB     r0,[r4,#0xf]          ;158
0000ae  79e0              LDRB     r0,[r4,#7]            ;159
0000b0  f08000ff          EOR      r0,r0,#0xff           ;159
0000b4  71e0              STRB     r0,[r4,#7]            ;159
0000b6  e04f              B        |L3.344|
                  |L3.184|
0000b8  79e0              LDRB     r0,[r4,#7]            ;163
0000ba  f08000ff          EOR      r0,r0,#0xff           ;163
0000be  71e0              STRB     r0,[r4,#7]            ;163
0000c0  e04a              B        |L3.344|
                  |L3.194|
0000c2  f1ba0f00          CMP      r10,#0                ;168
0000c6  d134              BNE      |L3.306|
0000c8  f1b80f00          CMP      r8,#0                 ;172
0000cc  d01e              BEQ      |L3.268|
0000ce  7b60              LDRB     r0,[r4,#0xd]          ;175
0000d0  f08000ff          EOR      r0,r0,#0xff           ;175
0000d4  7360              STRB     r0,[r4,#0xd]          ;175
0000d6  7960              LDRB     r0,[r4,#5]            ;176
0000d8  f08000ff          EOR      r0,r0,#0xff           ;176
0000dc  7160              STRB     r0,[r4,#5]            ;176
0000de  2500              MOVS     r5,#0                 ;177
0000e0  e004              B        |L3.236|
                  |L3.226|
0000e2  5d60              LDRB     r0,[r4,r5]            ;178
0000e4  a901              ADD      r1,sp,#4              ;178
0000e6  5548              STRB     r0,[r1,r5]            ;178
0000e8  1c68              ADDS     r0,r5,#1              ;177
0000ea  b2c5              UXTB     r5,r0                 ;177
                  |L3.236|
0000ec  2d10              CMP      r5,#0x10              ;177
0000ee  dbf8              BLT      |L3.226|
0000f0  2300              MOVS     r3,#0                 ;180
0000f2  aa03              ADD      r2,sp,#0xc            ;180
0000f4  a901              ADD      r1,sp,#4              ;180
0000f6  4620              MOV      r0,r4                 ;180
0000f8  f7fffffe          BL       tri_des
0000fc  2300              MOVS     r3,#0                 ;181
0000fe  aa03              ADD      r2,sp,#0xc            ;181
000100  a901              ADD      r1,sp,#4              ;181
000102  f1040008          ADD      r0,r4,#8              ;181
000106  f7fffffe          BL       tri_des
00010a  e011              B        |L3.304|
                  |L3.268|
00010c  7960              LDRB     r0,[r4,#5]            ;185
00010e  f08000ff          EOR      r0,r0,#0xff           ;185
000112  7160              STRB     r0,[r4,#5]            ;185
000114  2500              MOVS     r5,#0                 ;186
000116  e004              B        |L3.290|
                  |L3.280|
000118  5d60              LDRB     r0,[r4,r5]            ;187
00011a  a901              ADD      r1,sp,#4              ;187
00011c  5548              STRB     r0,[r1,r5]            ;187
00011e  1c68              ADDS     r0,r5,#1              ;186
000120  b2c5              UXTB     r5,r0                 ;186
                  |L3.290|
000122  2d08              CMP      r5,#8                 ;186
000124  dbf8              BLT      |L3.280|
000126  2200              MOVS     r2,#0                 ;189
000128  a901              ADD      r1,sp,#4              ;189
00012a  4620              MOV      r0,r4                 ;189
00012c  f7fffffe          BL       ||des||
                  |L3.304|
000130  e012              B        |L3.344|
                  |L3.306|
000132  f1ba0f02          CMP      r10,#2                ;193
000136  d10f              BNE      |L3.344|
000138  f1b80f00          CMP      r8,#0                 ;195
00013c  d008              BEQ      |L3.336|
00013e  7ba0              LDRB     r0,[r4,#0xe]          ;199
000140  f08000ff          EOR      r0,r0,#0xff           ;199
000144  73a0              STRB     r0,[r4,#0xe]          ;199
000146  79a0              LDRB     r0,[r4,#6]            ;200
000148  f08000ff          EOR      r0,r0,#0xff           ;200
00014c  71a0              STRB     r0,[r4,#6]            ;200
00014e  e003              B        |L3.344|
                  |L3.336|
000150  79a0              LDRB     r0,[r4,#6]            ;204
000152  f08000ff          EOR      r0,r0,#0xff           ;204
000156  71a0              STRB     r0,[r4,#6]            ;204
                  |L3.344|
000158  490a              LDR      r1,|L3.388|
00015a  980b              LDR      r0,[sp,#0x2c]         ;209
00015c  680a              LDR      r2,[r1,#0]            ;209  ; Track3TimeFlow
00015e  6002              STR      r2,[r0,#0]            ;209
000160  684a              LDR      r2,[r1,#4]            ;209  ; Track3TimeFlow
000162  6042              STR      r2,[r0,#4]            ;209
000164  8909              LDRH     r1,[r1,#8]            ;209  ; Track3TimeFlow
000166  8101              STRH     r1,[r0,#8]            ;209
000168  463a              MOV      r2,r7                 ;214
00016a  4659              MOV      r1,r11                ;214
00016c  a805              ADD      r0,sp,#0x14           ;214
00016e  f7fffffe          BL       IDT_GenNewKeys
000172  2001              MOVS     r0,#1                 ;218
000174  e75a              B        |L3.44|
;;;220    
                          ENDP

000176  0000              DCW      0x0000
                  |L3.376|
                          DCD      Track3TimeFlow
                  |L3.380|
                          DCD      gkeysize
                  |L3.384|
                          DCD      gLRC
                  |L3.388|
                          DCD      Track3TimeFlow+0x16d

                          AREA ||i.IDT_GenNewKeys||, CODE, READONLY, ALIGN=2

                  IDT_GenNewKeys PROC
;;;224    //-----------------------------------------------------------------------------
;;;225    void IDT_GenNewKeys(uint8_t *cryptoReg,
000000  b570              PUSH     {r4-r6,lr}
;;;226                        uint32_t shiftReg,
;;;227                        int currKeyPtr)
;;;228    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;229        // if the number of 1 bits in encryption counter is less than 10
;;;230        if (IDT_GetNumOfOnes(dukpt_key->encrypt_ctr) < 10)
000008  4921              LDR      r1,|L4.144|
00000a  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
00000c  f7fffffe          BL       IDT_GetNumOfOnes
000010  280a              CMP      r0,#0xa
000012  da21              BGE      |L4.88|
;;;231        {
;;;232            // Generating new keys:
;;;233            // new keys are generated by performing 3DES encryption using the current
;;;234            // key on the KSN whose encryption counter contains the same bit pattern
;;;235            // less the right most "1" bit:
;;;236    
;;;237            // Generate a set of new keys
;;;238            shiftReg >>= 1;
000014  086d              LSRS     r5,r5,#1
;;;239            IDT_PropogateKeys(cryptoReg, shiftReg, currKeyPtr);
000016  4622              MOV      r2,r4
000018  4629              MOV      r1,r5
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       IDT_PropogateKeys
;;;240            // Erase current key from memory
;;;241            memset(dukpt_key->future_key_reg[currKeyPtr], 0, (SIZE_3DES_KEY + 1));
000020  eb041204          ADD      r2,r4,r4,LSL #4
000024  491a              LDR      r1,|L4.144|
000026  3108              ADDS     r1,r1,#8
000028  1850              ADDS     r0,r2,r1
00002a  2111              MOVS     r1,#0x11
00002c  f7fffffe          BL       __aeabi_memclr
;;;242            dukpt_key->future_key_reg[currKeyPtr][gLRC] = 0xff;
000030  21ff              MOVS     r1,#0xff
000032  eb041204          ADD      r2,r4,r4,LSL #4
000036  4816              LDR      r0,|L4.144|
000038  3008              ADDS     r0,r0,#8
00003a  4410              ADD      r0,r0,r2
00003c  4a15              LDR      r2,|L4.148|
00003e  7812              LDRB     r2,[r2,#0]  ; gLRC
000040  5481              STRB     r1,[r0,r2]
;;;243            // Increment encryption counter and update it in key serial num register
;;;244            dukpt_key->encrypt_ctr++;
000042  4813              LDR      r0,|L4.144|
000044  6840              LDR      r0,[r0,#4]  ; Track3TimeFlow
000046  1c40              ADDS     r0,r0,#1
000048  4911              LDR      r1,|L4.144|
00004a  6048              STR      r0,[r1,#4]  ; Track3TimeFlow
;;;245            IDT_UpdateKSN(dukpt_key->encrypt_ctr, dukpt_key->initKSN);
00004c  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
00004e  f201116d          ADD      r1,r1,#0x16d
000052  f7fffffe          BL       IDT_UpdateKSN
000056  e01a              B        |L4.142|
                  |L4.88|
;;;246        }
;;;247        else
;;;248        {
;;;249            // Erase current key from memory
;;;250            memset(dukpt_key->future_key_reg[currKeyPtr], 0, (SIZE_3DES_KEY + 1));
000058  eb041204          ADD      r2,r4,r4,LSL #4
00005c  490c              LDR      r1,|L4.144|
00005e  3108              ADDS     r1,r1,#8
000060  1850              ADDS     r0,r2,r1
000062  2111              MOVS     r1,#0x11
000064  f7fffffe          BL       __aeabi_memclr
;;;251            dukpt_key->future_key_reg[currKeyPtr][gLRC] = 0xff;        // set LRC to invalid value
000068  21ff              MOVS     r1,#0xff
00006a  eb041204          ADD      r2,r4,r4,LSL #4
00006e  4808              LDR      r0,|L4.144|
000070  3008              ADDS     r0,r0,#8
000072  4410              ADD      r0,r0,r2
000074  4a07              LDR      r2,|L4.148|
000076  7812              LDRB     r2,[r2,#0]  ; gLRC
000078  5481              STRB     r1,[r0,r2]
;;;252    
;;;253            // Increment encryption counter and update it in key serial num register
;;;254            dukpt_key->encrypt_ctr += shiftReg;
00007a  4805              LDR      r0,|L4.144|
00007c  6840              LDR      r0,[r0,#4]  ; Track3TimeFlow
00007e  4428              ADD      r0,r0,r5
000080  4903              LDR      r1,|L4.144|
000082  6048              STR      r0,[r1,#4]  ; Track3TimeFlow
;;;255            IDT_UpdateKSN(dukpt_key->encrypt_ctr, dukpt_key->initKSN);
000084  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
000086  f201116d          ADD      r1,r1,#0x16d
00008a  f7fffffe          BL       IDT_UpdateKSN
                  |L4.142|
;;;256        }
;;;257    }
00008e  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP

                  |L4.144|
                          DCD      Track3TimeFlow
                  |L4.148|
                          DCD      gLRC

                          AREA ||i.IDT_GetNumOfOnes||, CODE, READONLY, ALIGN=1

                  IDT_GetNumOfOnes PROC
;;;348    //-----------------------------------------------------------------------------
;;;349    int IDT_GetNumOfOnes(uint32_t encCntr)
000000  b510              PUSH     {r4,lr}
;;;350    {
000002  4601              MOV      r1,r0
;;;351        int i,numOfOnes = 0;
000004  2000              MOVS     r0,#0
;;;352        uint32_t mask;
;;;353    
;;;354        // For each bit in encryption counter
;;;355        for (i = 0, mask = 0x01; i < 21; i++, mask <<= 1)
000006  2200              MOVS     r2,#0
000008  2301              MOVS     r3,#1
00000a  e004              B        |L5.22|
                  |L5.12|
;;;356        {
;;;357            if (encCntr & mask)
00000c  4219              TST      r1,r3
00000e  d000              BEQ      |L5.18|
;;;358                numOfOnes++;
000010  1c40              ADDS     r0,r0,#1
                  |L5.18|
000012  1c52              ADDS     r2,r2,#1              ;355
000014  005b              LSLS     r3,r3,#1              ;355
                  |L5.22|
000016  2a15              CMP      r2,#0x15              ;355
000018  dbf8              BLT      |L5.12|
;;;359        }
;;;360    
;;;361        return(numOfOnes);
;;;362    }
00001a  bd10              POP      {r4,pc}
;;;363    
                          ENDP


                          AREA ||i.IDT_GetSetBitPos||, CODE, READONLY, ALIGN=1

                  IDT_GetSetBitPos PROC
;;;286    //-----------------------------------------------------------------------------
;;;287    int IDT_GetSetBitPos(uint32_t reg)    // curent value of register
000000  4603              MOV      r3,r0
;;;288    {
;;;289        uint32_t   pos;    // position of set bit
;;;290        uint32_t   mask;   // running mask of set bit
;;;291    
;;;292        // Run the bit mask from right to left until we hit a set bit
;;;293        for (pos = 0, mask = 0x01; pos < NUM_BITS_EC; pos++, mask <<= 1)
000002  2100              MOVS     r1,#0
000004  2201              MOVS     r2,#1
000006  e004              B        |L6.18|
                  |L6.8|
;;;294        {
;;;295            if (reg & mask)
000008  4213              TST      r3,r2
00000a  d000              BEQ      |L6.14|
;;;296                break;
00000c  e003              B        |L6.22|
                  |L6.14|
00000e  1c49              ADDS     r1,r1,#1              ;293
000010  0052              LSLS     r2,r2,#1              ;293
                  |L6.18|
000012  2915              CMP      r1,#0x15              ;293
000014  d3f8              BCC      |L6.8|
                  |L6.22|
000016  bf00              NOP      
;;;297        }
;;;298    
;;;299        return((NUM_BITS_EC - 1) - pos);
000018  f1c10014          RSB      r0,r1,#0x14
;;;300    }
00001c  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.IDT_InitCryptoReg||, CODE, READONLY, ALIGN=1

                  IDT_InitCryptoReg PROC
;;;393    //-----------------------------------------------------------------------------
;;;394    void IDT_InitCryptoReg(uint8_t *cyptoReg,uint32_t shiftReg,uint8_t *ksnReg)
000000  b57f              PUSH     {r0-r6,lr}
;;;395    {
000002  4603              MOV      r3,r0
;;;396        uint32_t     i;
;;;397        uint8_t   buf1[SIZE_CRYP_REG] = {0};
000004  2400              MOVS     r4,#0
000006  9402              STR      r4,[sp,#8]
000008  9403              STR      r4,[sp,#0xc]
;;;398        uint8_t   buf2[SIZE_CRYP_REG] = {0};
00000a  9400              STR      r4,[sp,#0]
00000c  9401              STR      r4,[sp,#4]
;;;399    
;;;400        // Put the value of shift reg into the right most 3 bytes of temp buf 1
;;;401        for (i = 0; i < 3; i++) {
00000e  2000              MOVS     r0,#0
000010  e007              B        |L7.34|
                  |L7.18|
;;;402            buf1[(SIZE_CRYP_REG - 1) - i] =
000012  00c4              LSLS     r4,r0,#3
000014  fa21f404          LSR      r4,r1,r4
000018  f1c00507          RSB      r5,r0,#7
00001c  ae02              ADD      r6,sp,#8
00001e  5574              STRB     r4,[r6,r5]
000020  1c40              ADDS     r0,r0,#1              ;401
                  |L7.34|
000022  2803              CMP      r0,#3                 ;401
000024  d3f5              BCC      |L7.18|
;;;403                (uint8_t)((shiftReg >> (8 * i)) & 0xFF);;
;;;404        }
;;;405    
;;;406        // Put the right 8 bytes of key serial num into temp buf 2
;;;407        memcpy(buf2, (ksnReg + 2), SIZE_CRYP_REG);
000026  f8d24002          LDR      r4,[r2,#2]
00002a  9400              STR      r4,[sp,#0]
00002c  f8d24006          LDR      r4,[r2,#6]
000030  9401              STR      r4,[sp,#4]
;;;408    
;;;409        // OR them togather
;;;410        for (i = 0; i < SIZE_CRYP_REG; i++) {
000032  2000              MOVS     r0,#0
000034  e006              B        |L7.68|
                  |L7.54|
;;;411            cyptoReg[i] = buf1[i] | buf2[i];
000036  ac02              ADD      r4,sp,#8
000038  5c24              LDRB     r4,[r4,r0]
00003a  f81d5000          LDRB     r5,[sp,r0]
00003e  432c              ORRS     r4,r4,r5
000040  541c              STRB     r4,[r3,r0]
000042  1c40              ADDS     r0,r0,#1              ;410
                  |L7.68|
000044  2808              CMP      r0,#8                 ;410
000046  d3f6              BCC      |L7.54|
;;;412        }
;;;413    }
000048  bd7f              POP      {r0-r6,pc}
;;;414    
                          ENDP


                          AREA ||i.IDT_LoadInitKey||, CODE, READONLY, ALIGN=2

                  IDT_LoadInitKey PROC
;;;20     //-----------------------------------------------------------------------------
;;;21     int IDT_LoadInitKey(uint8_t isTDEA,         // indicate whether the key is single or double-length
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;22                         uint8_t *pInitKey,      // init key in binary
;;;23                         uint8_t *pInitKSN)      // init key serial number in binary
;;;24     {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;25         uint32_t  i;
;;;26         uint32_t  currKeyPtr;         // current key pointer
;;;27         uint8_t   cryptoReg[SIZE_PIN_BLK] = {0};  // crypto register
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  9001              STR      r0,[sp,#4]
000010  9002              STR      r0,[sp,#8]
000012  9003              STR      r0,[sp,#0xc]
;;;28     
;;;29         // Set global flag whether we will be doing single DES or triple DES.
;;;30     
;;;31         if (isTDEA) {
000014  b14e              CBZ      r6,|L8.42|
;;;32             gkeysize = SIZE_3DES_KEY;
000016  2010              MOVS     r0,#0x10
000018  4926              LDR      r1,|L8.180|
00001a  7008              STRB     r0,[r1,#0]
;;;33             gfkeyregsize = SIZE_3DES_KEY + 1;   // key size + 1 byte of LRC
00001c  2011              MOVS     r0,#0x11
00001e  4926              LDR      r1,|L8.184|
000020  7008              STRB     r0,[r1,#0]
;;;34             gLRC = SIZE_3DES_KEY;               // LRC byte follows the key
000022  2010              MOVS     r0,#0x10
000024  4925              LDR      r1,|L8.188|
000026  7008              STRB     r0,[r1,#0]
000028  e008              B        |L8.60|
                  |L8.42|
;;;35         }
;;;36         else {
;;;37             gkeysize = SIZE_DES_KEY;
00002a  2008              MOVS     r0,#8
00002c  4921              LDR      r1,|L8.180|
00002e  7008              STRB     r0,[r1,#0]
;;;38             gfkeyregsize = SIZE_DES_KEY + 1;    // key size + 1 byte of LRC
000030  2009              MOVS     r0,#9
000032  4921              LDR      r1,|L8.184|
000034  7008              STRB     r0,[r1,#0]
;;;39             gLRC = SIZE_DES_KEY;                // LRC byte follows the key
000036  2008              MOVS     r0,#8
000038  4920              LDR      r1,|L8.188|
00003a  7008              STRB     r0,[r1,#0]
                  |L8.60|
;;;40         }
;;;41     
;;;42         // Init all future key registers to zeros
;;;43         for (i = 0; i < NUM_FKEY_REG; i++)  memset(dukpt_key->future_key_reg[i], 0, (SIZE_3DES_KEY + 1));
00003c  2400              MOVS     r4,#0
00003e  e007              B        |L8.80|
                  |L8.64|
000040  eb041204          ADD      r2,r4,r4,LSL #4
000044  491e              LDR      r1,|L8.192|
000046  1850              ADDS     r0,r2,r1
000048  2111              MOVS     r1,#0x11
00004a  f7fffffe          BL       __aeabi_memclr
00004e  1c64              ADDS     r4,r4,#1
                  |L8.80|
000050  2c15              CMP      r4,#0x15
000052  d3f5              BCC      |L8.64|
;;;44     
;;;45         // clear encryption counter
;;;46         dukpt_key->encrypt_ctr = 0;
000054  2000              MOVS     r0,#0
000056  491a              LDR      r1,|L8.192|
000058  3908              SUBS     r1,r1,#8
00005a  6048              STR      r0,[r1,#4]  ; Track3TimeFlow
;;;47         // put address of key Reg #21 in CKP
;;;48         currKeyPtr = REG_21;
00005c  2514              MOVS     r5,#0x14
;;;49         // store initial key in future key reg #21
;;;50         memcpy(dukpt_key->future_key_reg[currKeyPtr], pInitKey, gkeysize);
00005e  eb051205          ADD      r2,r5,r5,LSL #4
000062  3108              ADDS     r1,r1,#8
000064  1850              ADDS     r0,r2,r1
000066  4913              LDR      r1,|L8.180|
000068  780a              LDRB     r2,[r1,#0]  ; gkeysize
00006a  4641              MOV      r1,r8
00006c  f7fffffe          BL       __aeabi_memcpy
;;;51         // copy initial key serial number to key serial num reg
;;;52         memcpy(dukpt_key->initKSN, pInitKSN, SIZE_KSN_REG);
000070  4814              LDR      r0,|L8.196|
000072  6839              LDR      r1,[r7,#0]
000074  6001              STR      r1,[r0,#0]  ; Track3TimeFlow
000076  6879              LDR      r1,[r7,#4]
000078  6041              STR      r1,[r0,#4]  ; Track3TimeFlow
00007a  8939              LDRH     r1,[r7,#8]
00007c  8101              STRH     r1,[r0,#8]
;;;53         // update counter in key serial num reg
;;;54         IDT_UpdateKSN(dukpt_key->encrypt_ctr, dukpt_key->initKSN);
00007e  f2a0116d          SUB      r1,r0,#0x16d
000082  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
000084  490f              LDR      r1,|L8.196|
000086  f7fffffe          BL       IDT_UpdateKSN
;;;55         // generate new keys, setting bit #1 in shift reg
;;;56         IDT_PropogateKeys(cryptoReg, BIT_1, currKeyPtr);
00008a  462a              MOV      r2,r5
00008c  f44f1180          MOV      r1,#0x100000
000090  4668              MOV      r0,sp
000092  f7fffffe          BL       IDT_PropogateKeys
;;;57         // clear current key pointed to
;;;58     //    memset(dukpt_key->future_key_reg[currKeyPtr], 0, (SIZE_3DES_KEY + 1));
;;;59         // set LRC to invalid value
;;;60     //    dukpt_key->future_key_reg[currKeyPtr][gLRC] = 0xff;
;;;61         // increment encryption counter
;;;62         dukpt_key->encrypt_ctr++;
000096  480a              LDR      r0,|L8.192|
000098  3808              SUBS     r0,r0,#8
00009a  6840              LDR      r0,[r0,#4]  ; Track3TimeFlow
00009c  1c40              ADDS     r0,r0,#1
00009e  4908              LDR      r1,|L8.192|
0000a0  3908              SUBS     r1,r1,#8
0000a2  6048              STR      r0,[r1,#4]  ; Track3TimeFlow
;;;63         // update counter in key serial num
;;;64         IDT_UpdateKSN(dukpt_key->encrypt_ctr, dukpt_key->initKSN);
0000a4  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
0000a6  4907              LDR      r1,|L8.196|
0000a8  f7fffffe          BL       IDT_UpdateKSN
;;;65     
;;;66         return DUKPT_SUCCESS;
0000ac  2001              MOVS     r0,#1
;;;67     }
0000ae  b004              ADD      sp,sp,#0x10
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;68     
                          ENDP

                  |L8.180|
                          DCD      gkeysize
                  |L8.184|
                          DCD      gfkeyregsize
                  |L8.188|
                          DCD      gLRC
                  |L8.192|
                          DCD      Track3TimeFlow+0x8
                  |L8.196|
                          DCD      Track3TimeFlow+0x16d

                          AREA ||i.IDT_NonReversibleKeyGen||, CODE, READONLY, ALIGN=2

                  IDT_NonReversibleKeyGen PROC
;;;519    //-----------------------------------------------------------------------------
;;;520    void IDT_NonReversibleKeyGen(uint8_t *cryptoReg,       // crypto register
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;521                                 uint8_t *key)             // key register
;;;522    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;523        uint8_t *cr1, *cr2;
;;;524        uint8_t *keyL, *keyR;
;;;525        uint8_t cArray[] = {
000008  a319              ADR      r3,|L9.112|
00000a  cb0f              LDM      r3,{r0-r3}
00000c  e88d000f          STM      sp,{r0-r3}
;;;526            0xc0, 0xc0, 0xc0, 0xc0,
;;;527            0x00, 0x00, 0x00, 0x00,
;;;528            0xc0, 0xc0, 0xc0, 0xc0,
;;;529            0x00, 0x00, 0x00, 0x00
;;;530        };
;;;531    
;;;532        cr1 = cryptoReg;
000010  4626              MOV      r6,r4
;;;533        cr2 = cryptoReg + SIZE_CRYP_REG;
000012  f1040708          ADD      r7,r4,#8
;;;534        keyL = key;
000016  46a8              MOV      r8,r5
;;;535        keyR = key + SIZE_CRYP_REG;
000018  f1050908          ADD      r9,r5,#8
;;;536    
;;;537        // CR-2 = CR-1 xor KR-R
;;;538        memcpy(cr2, cr1, SIZE_CRYP_REG);       // copy content of CR-1 to CR-2
00001c  6830              LDR      r0,[r6,#0]
00001e  6038              STR      r0,[r7,#0]
000020  6870              LDR      r0,[r6,#4]
000022  6078              STR      r0,[r7,#4]
;;;539        xor(cr2, keyR, SIZE_CRYP_REG);
000024  2208              MOVS     r2,#8
000026  4649              MOV      r1,r9
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       xor
;;;540        // CR-2 = DEAen(CR-2, KR-L)
;;;541    
;;;542    //    encrypt(SIZE_CRYP_REG, cr2, keyL);
;;;543        des(cr2, keyL,0);   //single encryption
00002e  2200              MOVS     r2,#0
000030  4641              MOV      r1,r8
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       ||des||
;;;544    
;;;545        // CR-2 = CR-2 xor KR-R
;;;546        xor(cr2, keyR, SIZE_CRYP_REG);
000038  2208              MOVS     r2,#8
00003a  4649              MOV      r1,r9
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       xor
;;;547        // KR = KR xor c0c0 c0c0 0000 0000 c0c0 c0c0 0000 0000
;;;548        xor(key, cArray, SIZE_3DES_KEY);
000042  2210              MOVS     r2,#0x10
000044  4669              MOV      r1,sp
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       xor
;;;549        // CR-1 = CR-1 xor KR-R
;;;550        xor(cr1, keyR, SIZE_CRYP_REG);
00004c  2208              MOVS     r2,#8
00004e  4649              MOV      r1,r9
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       xor
;;;551        // CR-1 = DEAen(CR-1, KR-L)
;;;552    
;;;553    //    encrypt(SIZE_CRYP_REG, cr1, keyL);
;;;554        des(cr1, keyL,0);   //single encryption
000056  2200              MOVS     r2,#0
000058  4641              MOV      r1,r8
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       ||des||
;;;555        // CR-1 = CR-1 xor KR-R
;;;556        xor(cr1, keyR, SIZE_CRYP_REG);
000060  2208              MOVS     r2,#8
000062  4649              MOV      r1,r9
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       xor
;;;557    }
00006a  e8bd87ff          POP      {r0-r10,pc}
;;;558    
                          ENDP

00006e  0000              DCW      0x0000
                  |L9.112|
000070  c0c0c0c0          DCB      192,192,192,192,0
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
000078  c0c0c0c0          DCB      192,192,192,192,0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.IDT_PropogateKeys||, CODE, READONLY, ALIGN=2

                  IDT_PropogateKeys PROC
;;;418    //-----------------------------------------------------------------------------
;;;419    void IDT_PropogateKeys(uint8_t *cryptoReg,          // crypto register
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;420                           uint32_t shiftReg,           // shift register
;;;421                           int currKeyPtr)         // current key pointer
;;;422    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;423        int  posSR, posEC;
;;;424        uint8_t   *cr1, *cr2;
;;;425        uint8_t   *fkeyRegL, *fkeyRegR;
;;;426        uint8_t   swap1, swap2;
;;;427    
;;;428        cr1 = cryptoReg;
00000a  46b2              MOV      r10,r6
;;;429        cr2 = cryptoReg + SIZE_CRYP_REG;
00000c  f1060008          ADD      r0,r6,#8
000010  9002              STR      r0,[sp,#8]
;;;430    
;;;431        while (shiftReg)                     // do while shift reg no zero
000012  e062              B        |L10.218|
                  |L10.20|
;;;432        {
;;;433            // Init cyrpto reg by ORing lower 64 bits of KSN with shift reg
;;;434            IDT_InitCryptoReg(cryptoReg, shiftReg, dukpt_key->initKSN);
000014  4a33              LDR      r2,|L10.228|
000016  4639              MOV      r1,r7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       IDT_InitCryptoReg
;;;435    
;;;436    #ifdef DBG
;;;437            if (debug) {
;;;438                if (outFile)
;;;439                    fprintf(fp, "EC = %02X%02X%02X ",
;;;440                            cryptoReg[5] & 0x1F, cryptoReg[6], cryptoReg[7]);
;;;441                else
;;;442                    printf("EC = %02X%02X%02X ",
;;;443                           cryptoReg[5] & 0x1F, cryptoReg[6], cryptoReg[7]);
;;;444            }
;;;445    #endif // DBG
;;;446    
;;;447            // find position of least significant set bit in shift reg
;;;448            posSR = IDT_GetSetBitPos(shiftReg);
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       IDT_GetSetBitPos
000024  4604              MOV      r4,r0
;;;449            swap1 = posSR % 2;
000026  4620              MOV      r0,r4
000028  eb0471d0          ADD      r1,r4,r0,LSR #31
00002c  1049              ASRS     r1,r1,#1
00002e  eba40141          SUB      r1,r4,r1,LSL #1
000032  b2c9              UXTB     r1,r1
000034  9101              STR      r1,[sp,#4]
;;;450            fkeyRegL = dukpt_key->future_key_reg[posSR];
000036  eb041104          ADD      r1,r4,r4,LSL #4
00003a  482b              LDR      r0,|L10.232|
00003c  eb010800          ADD      r8,r1,r0
;;;451            fkeyRegR = fkeyRegL + SIZE_CRYP_REG;
000040  f1080b08          ADD      r11,r8,#8
;;;452    
;;;453     //       if (dukpt_key->keytype) {
;;;454    		if (1)
;;;455    		{
;;;456    		
;;;457                // if we use double length key, geneate a new double length key using
;;;458                // this folloiwng call:
;;;459                IDT_NonReversibleKeyGen(cryptoReg, dukpt_key->future_key_reg[currKeyPtr]);
000044  eb091209          ADD      r2,r9,r9,LSL #4
000048  1811              ADDS     r1,r2,r0
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       IDT_NonReversibleKeyGen
;;;460    
;;;461    #ifdef SWAP
;;;462                // find position of least significant set bit in encryption counter
;;;463                posEC = IDT_GetSetBitPos(dukpt_key->encrypt_ctr);
000050  4925              LDR      r1,|L10.232|
000052  3908              SUBS     r1,r1,#8
000054  6848              LDR      r0,[r1,#4]  ; Track3TimeFlow
000056  f7fffffe          BL       IDT_GetSetBitPos
00005a  4605              MOV      r5,r0
;;;464                swap2 = posEC % 2;
00005c  4628              MOV      r0,r5
00005e  eb0571d0          ADD      r1,r5,r0,LSR #31
000062  1049              ASRS     r1,r1,#1
000064  eba50141          SUB      r1,r5,r1,LSL #1
000068  b2c9              UXTB     r1,r1
00006a  9100              STR      r1,[sp,#0]
;;;465                if (dukpt_key->encrypt_ctr)
00006c  481e              LDR      r0,|L10.232|
00006e  3808              SUBS     r0,r0,#8
000070  6840              LDR      r0,[r0,#4]  ; Track3TimeFlow
000072  b120              CBZ      r0,|L10.126|
;;;466                    swap2 ^= 1;
000074  9800              LDR      r0,[sp,#0]
000076  f0800001          EOR      r0,r0,#1
00007a  9000              STR      r0,[sp,#0]
00007c  e001              B        |L10.130|
                  |L10.126|
;;;467                else
;;;468                    swap2 = 0;
00007e  2000              MOVS     r0,#0
000080  9000              STR      r0,[sp,#0]
                  |L10.130|
;;;469    
;;;470                if (swap2)
000082  9800              LDR      r0,[sp,#0]
000084  b118              CBZ      r0,|L10.142|
;;;471                    swap1 ^= 1;
000086  9801              LDR      r0,[sp,#4]
000088  f0800001          EOR      r0,r0,#1
00008c  9001              STR      r0,[sp,#4]
                  |L10.142|
;;;472    
;;;473                if (swap1) {
00008e  9801              LDR      r0,[sp,#4]
000090  b178              CBZ      r0,|L10.178|
;;;474                    // HACK: swap upper and lower 8 bytes
;;;475                    memcpy(fkeyRegR, cr1, SIZE_CRYP_REG);
000092  f8da0000          LDR      r0,[r10,#0]
000096  f8cb0000          STR      r0,[r11,#0]
00009a  f8da0004          LDR      r0,[r10,#4]
00009e  f8cb0004          STR      r0,[r11,#4]
;;;476                    memcpy(fkeyRegL, cr2, SIZE_CRYP_REG);
0000a2  9802              LDR      r0,[sp,#8]
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f8c81000          STR      r1,[r8,#0]
0000aa  6840              LDR      r0,[r0,#4]
0000ac  f8c80004          STR      r0,[r8,#4]
0000b0  e008              B        |L10.196|
                  |L10.178|
;;;477                }
;;;478                else {
;;;479                    // copy new key into future key reg pointed by this position
;;;480                    memcpy(dukpt_key->future_key_reg[posSR], cryptoReg, gkeysize);
0000b2  eb041204          ADD      r2,r4,r4,LSL #4
0000b6  490c              LDR      r1,|L10.232|
0000b8  1850              ADDS     r0,r2,r1
0000ba  490c              LDR      r1,|L10.236|
0000bc  780a              LDRB     r2,[r1,#0]  ; gkeysize
0000be  4631              MOV      r1,r6
0000c0  f7fffffe          BL       __aeabi_memcpy
                  |L10.196|
;;;481                }
;;;482    #else
;;;483                // copy new key into the future key reg pointed by this position
;;;484                memcpy(dukpt_key->future_key_reg[posSR], cryptoReg, gkeysize);
;;;485    #endif
;;;486    
;;;487            }
;;;488            else {
;;;489                // if we use single length key, generate a new single length key
;;;490                // using the follwing call which use all 64-bit when generating
;;;491                // key
;;;492                IDT_SpecialDEAEncrypt(cryptoReg, dukpt_key->future_key_reg[currKeyPtr]);
;;;493                // copy new key into the future key reg pointed by this position
;;;494                memcpy(dukpt_key->future_key_reg[posSR], cryptoReg, gkeysize);
;;;495            }
;;;496    
;;;497            // calc LRC and store with new key
;;;498            dukpt_key->future_key_reg[posSR][gLRC] = IDT_CalcLRC(cryptoReg);
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       IDT_CalcLRC
0000ca  eb041204          ADD      r2,r4,r4,LSL #4
0000ce  4906              LDR      r1,|L10.232|
0000d0  4411              ADD      r1,r1,r2
0000d2  4a07              LDR      r2,|L10.240|
0000d4  7812              LDRB     r2,[r2,#0]  ; gLRC
0000d6  5488              STRB     r0,[r1,r2]
;;;499    
;;;500            // shift sr right 1 bit
;;;501            shiftReg >>= 1;
0000d8  087f              LSRS     r7,r7,#1
                  |L10.218|
0000da  2f00              CMP      r7,#0                 ;431
0000dc  d19a              BNE      |L10.20|
;;;502        }
;;;503    }
0000de  e8bd8ffe          POP      {r1-r11,pc}
;;;504    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L10.228|
                          DCD      Track3TimeFlow+0x16d
                  |L10.232|
                          DCD      Track3TimeFlow+0x8
                  |L10.236|
                          DCD      gkeysize
                  |L10.240|
                          DCD      gLRC

                          AREA ||i.IDT_SetBit||, CODE, READONLY, ALIGN=1

                  IDT_SetBit PROC
;;;307    //-----------------------------------------------------------------------------
;;;308    uint32_t IDT_SetBit(uint32_t reg,int pos)
000000  4602              MOV      r2,r0
;;;309    {
;;;310        return (reg |= 1L << ((NUM_BITS_EC - 1) - pos));
000002  f1c10314          RSB      r3,r1,#0x14
000006  2001              MOVS     r0,#1
000008  4098              LSLS     r0,r0,r3
00000a  4310              ORRS     r0,r0,r2
00000c  4602              MOV      r2,r0
;;;311    }
00000e  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.IDT_SpecialDEAEncrypt||, CODE, READONLY, ALIGN=1

                  IDT_SpecialDEAEncrypt PROC
;;;272    //-----------------------------------------------------------------------------
;;;273    void IDT_SpecialDEAEncrypt(uint8_t *cryptoReg,uint8_t *key)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;275        xor(cryptoReg, key, SIZE_PIN_BLK);
000006  2210              MOVS     r2,#0x10
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       xor
;;;276        des(cryptoReg, key, 0);   //single encryption
000010  2200              MOVS     r2,#0
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       ||des||
;;;277        xor(cryptoReg, key, SIZE_PIN_BLK);
00001a  2210              MOVS     r2,#0x10
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       xor
;;;278    }
000024  bd70              POP      {r4-r6,pc}
;;;279    
                          ENDP


                          AREA ||i.IDT_UpdateKSN||, CODE, READONLY, ALIGN=1

                  IDT_UpdateKSN PROC
;;;337    //-----------------------------------------------------------------------------
;;;338    void IDT_UpdateKSN(uint32_t encCntr,uint8_t *pKsnReg)
000000  7248              STRB     r0,[r1,#9]
;;;339    {
;;;340        pKsnReg[9] = (uint8_t)(encCntr & 0xFF);
;;;341        pKsnReg[8] = (uint8_t)((encCntr >> 8) & 0xFF);
000002  0a02              LSRS     r2,r0,#8
000004  720a              STRB     r2,[r1,#8]
;;;342        pKsnReg[7] = (pKsnReg[7] & 0xE0) | (uint8_t)((encCntr >> 16) & 0xFF);
000006  79ca              LDRB     r2,[r1,#7]
000008  f00202e0          AND      r2,r2,#0xe0
00000c  f3c04307          UBFX     r3,r0,#16,#8
000010  431a              ORRS     r2,r2,r3
000012  71ca              STRB     r2,[r1,#7]
;;;343    }
000014  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  gkeysize
000000  00                DCB      0x00
                  gfkeyregsize
000001  00                DCB      0x00
                  gLRC
000002  00                DCB      0x00
