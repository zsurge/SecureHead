; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\user -I..\dev -I..\lib\inc -I..\core_cm3 -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\stm32f10x_it.crf ..\dev\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;84       */
;;;85     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;86     {
;;;87       /* Go to infinite loop when Bus Fault exception occurs */
;;;88       while (1)
000002  e7fe              B        |L1.2|
;;;89       {}
;;;90     }
;;;91     
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;108      */
;;;109    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;110    {}
;;;111    
                          ENDP


                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI0_IRQHandler PROC
;;;275    *******************************************************************************/
;;;276    void EXTI0_IRQHandler(void)																		/*二磁道中断捕获响应*/
000000  b510              PUSH     {r4,lr}
;;;277    {
;;;278    	if (EXTI_GetITStatus(EXTI_Line0) == SET) {
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2801              CMP      r0,#1
00000a  d13d              BNE      |L3.136|
;;;279    		EXTI_ClearITPendingBit(EXTI_Line0);  													/*清除中断标记*/
00000c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;280    		if (TM2CaptureNumber <= FILTERNUM) {													//过滤前面的干扰
000010  481e              LDR      r0,|L3.140|
000012  7800              LDRB     r0,[r0,#0]  ; TM2CaptureNumber
000014  2802              CMP      r0,#2
000016  dc0a              BGT      |L3.46|
;;;281    			/* Get the Input Capture value */
;;;282    			TM2ReadValue1 = TIM2->CNT;															//第一次取值
000018  f04f4080          MOV      r0,#0x40000000
00001c  8c80              LDRH     r0,[r0,#0x24]
00001e  491c              LDR      r1,|L3.144|
000020  8008              STRH     r0,[r1,#0]
;;;283    			TM2CaptureNumber++;
000022  481a              LDR      r0,|L3.140|
000024  7800              LDRB     r0,[r0,#0]  ; TM2CaptureNumber
000026  1c40              ADDS     r0,r0,#1
000028  4918              LDR      r1,|L3.140|
00002a  7008              STRB     r0,[r1,#0]
00002c  e02c              B        |L3.136|
                  |L3.46|
;;;284    		} else if (Track2TimeFlow.Length < TRACK2TIMEFLOWLENGTH ) {								//判断接收缓存是否满
00002e  4819              LDR      r0,|L3.148|
000030  f8b003e8          LDRH     r0,[r0,#0x3e8]  ; Track2TimeFlow
000034  f5b07ffa          CMP      r0,#0x1f4
000038  da26              BGE      |L3.136|
;;;285    			/* Get the Input Capture value */
;;;286    			TM2ReadValue2 = TIM2->CNT;															//第二次取值
00003a  f04f4080          MOV      r0,#0x40000000
00003e  8c80              LDRH     r0,[r0,#0x24]
000040  4915              LDR      r1,|L3.152|
000042  8008              STRH     r0,[r1,#0]
;;;287    
;;;288    			/* Capture computation */
;;;289    			#ifndef TIMERFLOW_12BIT
;;;290    			if (TM2ReadValue2 > TM2ReadValue1) {
000044  4608              MOV      r0,r1
000046  8800              LDRH     r0,[r0,#0]  ; TM2ReadValue2
000048  4911              LDR      r1,|L3.144|
00004a  8809              LDRH     r1,[r1,#0]  ; TM2ReadValue1
00004c  4288              CMP      r0,r1
00004e  dd0a              BLE      |L3.102|
;;;291    				//Track2TimeFlow.Value[Track2TimeFlow.Length++]  = (TM2ReadValue2 - TM2ReadValue1); 
;;;292    				SetF2FInputBuffer(1, TM2ReadValue2 - TM2ReadValue1, 0);
000050  4811              LDR      r0,|L3.152|
000052  8800              LDRH     r0,[r0,#0]  ; TM2ReadValue2
000054  4a0e              LDR      r2,|L3.144|
000056  8812              LDRH     r2,[r2,#0]  ; TM2ReadValue1
000058  1a80              SUBS     r0,r0,r2
00005a  b281              UXTH     r1,r0
00005c  2200              MOVS     r2,#0
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       SetF2FInputBuffer
000064  e00c              B        |L3.128|
                  |L3.102|
;;;293    			} else {
;;;294    				//Track2TimeFlow.Value[Track2TimeFlow.Length++]  = ((0xFFFF - TM2ReadValue1) + TM2ReadValue2); 
;;;295    				SetF2FInputBuffer(1, 0xFFFF - TM2ReadValue1 + TM2ReadValue2, 0);
000066  480a              LDR      r0,|L3.144|
000068  8800              LDRH     r0,[r0,#0]  ; TM2ReadValue1
00006a  f64f72ff          MOV      r2,#0xffff
00006e  1a10              SUBS     r0,r2,r0
000070  4a09              LDR      r2,|L3.152|
000072  8812              LDRH     r2,[r2,#0]  ; TM2ReadValue2
000074  4410              ADD      r0,r0,r2
000076  b281              UXTH     r1,r0
000078  2200              MOVS     r2,#0
00007a  2001              MOVS     r0,#1
00007c  f7fffffe          BL       SetF2FInputBuffer
                  |L3.128|
;;;296    			}
;;;297    			#else
;;;298    			_input_12bit_data(Track2TimeFlow.Value, Track2TimeFlow.Length, ((TM2ReadValue1 + 0x10000) - TM2ReadValue2) % (0x10000));
;;;299    			Track2TimeFlow.Length++;
;;;300    			#endif
;;;301    			TM2ReadValue1 = TM2ReadValue2;
000080  4805              LDR      r0,|L3.152|
000082  8800              LDRH     r0,[r0,#0]  ; TM2ReadValue2
000084  4902              LDR      r1,|L3.144|
000086  8008              STRH     r0,[r1,#0]
                  |L3.136|
;;;302        	}
;;;303    	}
;;;304    }
000088  bd10              POP      {r4,pc}
;;;305    
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      TM2CaptureNumber
                  |L3.144|
                          DCD      TM2ReadValue1
                  |L3.148|
                          DCD      Track2TimeFlow
                  |L3.152|
                          DCD      TM2ReadValue2

                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI15_10_IRQHandler PROC
;;;356    *******************************************************************************/
;;;357    void EXTI15_10_IRQHandler(void)																		/*一磁道中断捕获响应*/
000000  b510              PUSH     {r4,lr}
;;;358    {
;;;359    	if(EXTI_GetITStatus(EXTI_Line10) == SET)
000002  f44f6080          MOV      r0,#0x400
000006  f7fffffe          BL       EXTI_GetITStatus
00000a  2801              CMP      r0,#1
00000c  d13f              BNE      |L4.142|
;;;360    	{
;;;361    		EXTI_ClearITPendingBit(EXTI_Line10);  /*清除中断标记*/
00000e  0280              LSLS     r0,r0,#10
000010  f7fffffe          BL       EXTI_ClearITPendingBit
;;;362    		if (TM1CaptureNumber <= FILTERNUM) {
000014  481e              LDR      r0,|L4.144|
000016  7800              LDRB     r0,[r0,#0]  ; TM1CaptureNumber
000018  2802              CMP      r0,#2
00001a  dc0a              BGT      |L4.50|
;;;363    			/* Get the Input Capture value */
;;;364    			TM1ReadValue1 = TIM2->CNT;																//第一次取值
00001c  f04f4080          MOV      r0,#0x40000000
000020  8c80              LDRH     r0,[r0,#0x24]
000022  491c              LDR      r1,|L4.148|
000024  8008              STRH     r0,[r1,#0]
;;;365    			TM1CaptureNumber++;
000026  481a              LDR      r0,|L4.144|
000028  7800              LDRB     r0,[r0,#0]  ; TM1CaptureNumber
00002a  1c40              ADDS     r0,r0,#1
00002c  4918              LDR      r1,|L4.144|
00002e  7008              STRB     r0,[r1,#0]
000030  e02d              B        |L4.142|
                  |L4.50|
;;;366    		} else if (Track1TimeFlow.Length < TRACK1TIMEFLOWLENGTH ) {									//判断接收缓存是否满
000032  4819              LDR      r0,|L4.152|
000034  f8b00898          LDRH     r0,[r0,#0x898]
000038  f240414c          MOV      r1,#0x44c
00003c  4288              CMP      r0,r1
00003e  da26              BGE      |L4.142|
;;;367    			/* Get the Input Capture value */
;;;368    			TM1ReadValue2 = TIM2->CNT;																//第二次取值
000040  f04f4080          MOV      r0,#0x40000000
000044  8c80              LDRH     r0,[r0,#0x24]
000046  4915              LDR      r1,|L4.156|
000048  8008              STRH     r0,[r1,#0]
;;;369    
;;;370    			/* Capture computation */
;;;371    			#ifndef TIMERFLOW_12BIT
;;;372    			if (TM1ReadValue2 > TM1ReadValue1) {
00004a  4608              MOV      r0,r1
00004c  8800              LDRH     r0,[r0,#0]  ; TM1ReadValue2
00004e  4911              LDR      r1,|L4.148|
000050  8809              LDRH     r1,[r1,#0]  ; TM1ReadValue1
000052  4288              CMP      r0,r1
000054  dd0a              BLE      |L4.108|
;;;373    				//Track1TimeFlow.Value[Track1TimeFlow.Length++]  = (TM1ReadValue2 - TM1ReadValue1); 
;;;374    				SetF2FInputBuffer(0, TM1ReadValue2 - TM1ReadValue1, 0);
000056  4811              LDR      r0,|L4.156|
000058  8800              LDRH     r0,[r0,#0]  ; TM1ReadValue2
00005a  4a0e              LDR      r2,|L4.148|
00005c  8812              LDRH     r2,[r2,#0]  ; TM1ReadValue1
00005e  1a80              SUBS     r0,r0,r2
000060  b281              UXTH     r1,r0
000062  2200              MOVS     r2,#0
000064  4610              MOV      r0,r2
000066  f7fffffe          BL       SetF2FInputBuffer
00006a  e00c              B        |L4.134|
                  |L4.108|
;;;375    			} else {
;;;376    				//Track1TimeFlow.Value[Track1TimeFlow.Length++]  = ((0xFFFF - TM1ReadValue1) + TM1ReadValue2); 
;;;377    				SetF2FInputBuffer(0, (0xFFFF - TM1ReadValue1) + TM1ReadValue2, 0);
00006c  4809              LDR      r0,|L4.148|
00006e  8800              LDRH     r0,[r0,#0]  ; TM1ReadValue1
000070  f64f72ff          MOV      r2,#0xffff
000074  1a10              SUBS     r0,r2,r0
000076  4a09              LDR      r2,|L4.156|
000078  8812              LDRH     r2,[r2,#0]  ; TM1ReadValue2
00007a  4410              ADD      r0,r0,r2
00007c  b281              UXTH     r1,r0
00007e  2200              MOVS     r2,#0
000080  4610              MOV      r0,r2
000082  f7fffffe          BL       SetF2FInputBuffer
                  |L4.134|
;;;378    			}
;;;379    			#else
;;;380    			_input_12bit_data(Track1TimeFlow.Value, Track1TimeFlow.Length, ((TM1ReadValue1 + 0x10000) - TM1ReadValue2) % (0x10000));
;;;381    			Track1TimeFlow.Length++;
;;;382    			#endif
;;;383    			
;;;384    			TM1ReadValue1 = TM1ReadValue2;
000086  4805              LDR      r0,|L4.156|
000088  8800              LDRH     r0,[r0,#0]  ; TM1ReadValue2
00008a  4902              LDR      r1,|L4.148|
00008c  8008              STRH     r0,[r1,#0]
                  |L4.142|
;;;385        	}
;;;386    	}
;;;387    }
00008e  bd10              POP      {r4,pc}
;;;388    
                          ENDP

                  |L4.144|
                          DCD      TM1CaptureNumber
                  |L4.148|
                          DCD      TM1ReadValue1
                  |L4.152|
                          DCD      Track1TimeFlow
                  |L4.156|
                          DCD      TM1ReadValue2

                          AREA ||i.EXTI4_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI4_IRQHandler PROC
;;;234    *******************************************************************************/
;;;235    void EXTI4_IRQHandler(void)												/*刷卡中断响应函数*/
000000  b510              PUSH     {r4,lr}
;;;236    {
;;;237    	if (EXTI_GetITStatus(EXTI_Line4) == SET) {							//刷卡中断来了
000002  2010              MOVS     r0,#0x10
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2801              CMP      r0,#1
00000a  d114              BNE      |L5.54|
;;;238    		EXTI_ClearITPendingBit(EXTI_Line4);								/*清除中断标记*/
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;239    		if (0 == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_4)) {			
000012  2110              MOVS     r1,#0x10
000014  4808              LDR      r0,|L5.56|
000016  f7fffffe          BL       GPIO_ReadInputDataBit
00001a  b930              CBNZ     r0,|L5.42|
;;;240    			MSR_Check_Sync_Pattern();
00001c  f7fffffe          BL       MSR_Check_Sync_Pattern
;;;241    			TIM_Cmd(TIM3, ENABLE);										//开启定时器
000020  2101              MOVS     r1,#1
000022  4806              LDR      r0,|L5.60|
000024  f7fffffe          BL       TIM_Cmd
000028  e005              B        |L5.54|
                  |L5.42|
;;;242    		} else {
;;;243    			MSR_WaitForReady();											//刷卡完成
00002a  f7fffffe          BL       MSR_WaitForReady
;;;244    			TIM_Cmd(TIM3, DISABLE);	
00002e  2100              MOVS     r1,#0
000030  4802              LDR      r0,|L5.60|
000032  f7fffffe          BL       TIM_Cmd
                  |L5.54|
;;;245    		}
;;;246    	}
;;;247    }
000036  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  |L5.56|
                          DCD      0x40010800
                  |L5.60|
                          DCD      0x40000400

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;315    *******************************************************************************/
;;;316    void EXTI9_5_IRQHandler(void)																	/*三磁道中断捕获响应*/
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318    	if(EXTI_GetITStatus(EXTI_Line6) == SET)
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2801              CMP      r0,#1
00000a  d13e              BNE      |L6.138|
;;;319    	{
;;;320    		EXTI_ClearITPendingBit(EXTI_Line6);  /*清除中断标记*/
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;321    		if (TM3CaptureNumber <= FILTERNUM) {
000012  481e              LDR      r0,|L6.140|
000014  7800              LDRB     r0,[r0,#0]  ; TM3CaptureNumber
000016  2802              CMP      r0,#2
000018  dc0a              BGT      |L6.48|
;;;322    			/* Get the Input Capture value */
;;;323    			TM3ReadValue1 = TIM2->CNT;															//第一次取值
00001a  f04f4080          MOV      r0,#0x40000000
00001e  8c80              LDRH     r0,[r0,#0x24]
000020  491b              LDR      r1,|L6.144|
000022  8008              STRH     r0,[r1,#0]
;;;324    			TM3CaptureNumber++;
000024  4819              LDR      r0,|L6.140|
000026  7800              LDRB     r0,[r0,#0]  ; TM3CaptureNumber
000028  1c40              ADDS     r0,r0,#1
00002a  4918              LDR      r1,|L6.140|
00002c  7008              STRB     r0,[r1,#0]
00002e  e02c              B        |L6.138|
                  |L6.48|
;;;325    		} else if (Track3TimeFlow.Length < TRACK3TIMEFLOWLENGTH ) {								//判断接收缓存是否满
000030  4818              LDR      r0,|L6.148|
000032  f8b00870          LDRH     r0,[r0,#0x870]
000036  f5b06f87          CMP      r0,#0x438
00003a  da26              BGE      |L6.138|
;;;326    			/* Get the Input Capture value */
;;;327    			TM3ReadValue2 = TIM2->CNT;															//第二次取值
00003c  f04f4080          MOV      r0,#0x40000000
000040  8c80              LDRH     r0,[r0,#0x24]
000042  4915              LDR      r1,|L6.152|
000044  8008              STRH     r0,[r1,#0]
;;;328    
;;;329    			/* Capture computation */
;;;330    			#ifndef TIMERFLOW_12BIT
;;;331    			if (TM3ReadValue2 > TM3ReadValue1) {
000046  4608              MOV      r0,r1
000048  8800              LDRH     r0,[r0,#0]  ; TM3ReadValue2
00004a  4911              LDR      r1,|L6.144|
00004c  8809              LDRH     r1,[r1,#0]  ; TM3ReadValue1
00004e  4288              CMP      r0,r1
000050  dd0a              BLE      |L6.104|
;;;332    				//Track3TimeFlow.Value[Track3TimeFlow.Length++]  = (TM3ReadValue2 - TM3ReadValue1); 
;;;333    				SetF2FInputBuffer(2, TM3ReadValue2 - TM3ReadValue1, 0);
000052  4811              LDR      r0,|L6.152|
000054  8800              LDRH     r0,[r0,#0]  ; TM3ReadValue2
000056  4a0e              LDR      r2,|L6.144|
000058  8812              LDRH     r2,[r2,#0]  ; TM3ReadValue1
00005a  1a80              SUBS     r0,r0,r2
00005c  b281              UXTH     r1,r0
00005e  2200              MOVS     r2,#0
000060  2002              MOVS     r0,#2
000062  f7fffffe          BL       SetF2FInputBuffer
000066  e00c              B        |L6.130|
                  |L6.104|
;;;334    			} else {
;;;335    				//Track3TimeFlow.Value[Track3TimeFlow.Length++]  = ((0xFFFF - TM3ReadValue1) + TM3ReadValue2); 
;;;336    				SetF2FInputBuffer(2, 0xFFFF - TM3ReadValue1 + TM3ReadValue2, 0);
000068  4809              LDR      r0,|L6.144|
00006a  8800              LDRH     r0,[r0,#0]  ; TM3ReadValue1
00006c  f64f72ff          MOV      r2,#0xffff
000070  1a10              SUBS     r0,r2,r0
000072  4a09              LDR      r2,|L6.152|
000074  8812              LDRH     r2,[r2,#0]  ; TM3ReadValue2
000076  4410              ADD      r0,r0,r2
000078  b281              UXTH     r1,r0
00007a  2200              MOVS     r2,#0
00007c  2002              MOVS     r0,#2
00007e  f7fffffe          BL       SetF2FInputBuffer
                  |L6.130|
;;;337    			}
;;;338    			#else
;;;339    			_input_12bit_data(Track3TimeFlow.Value, Track3TimeFlow.Length, ((TM3ReadValue1 + 0x10000) - TM3ReadValue2) % (0x10000));
;;;340    			Track3TimeFlow.Length++;
;;;341    			#endif
;;;342    			
;;;343    			TM3ReadValue1 = TM3ReadValue2;
000082  4805              LDR      r0,|L6.152|
000084  8800              LDRH     r0,[r0,#0]  ; TM3ReadValue2
000086  4902              LDR      r1,|L6.144|
000088  8008              STRH     r0,[r1,#0]
                  |L6.138|
;;;344        	}
;;;345    	}
;;;346    }
00008a  bd10              POP      {r4,pc}
;;;347    
                          ENDP

                  |L6.140|
                          DCD      TM3CaptureNumber
                  |L6.144|
                          DCD      TM3ReadValue1
                  |L6.148|
                          DCD      Track3TimeFlow
                  |L6.152|
                          DCD      TM3ReadValue2

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;60       */
;;;61     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L7.2|
;;;62     {
;;;63       /* Go to infinite loop when Hard Fault exception occurs */
;;;64       while (1)
000002  e7fe              B        |L7.2|
;;;65       {}
;;;66     }
;;;67     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;72       */
;;;73     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L8.2|
;;;74     {
;;;75       /* Go to infinite loop when Memory Manage exception occurs */
;;;76       while (1)
000002  e7fe              B        |L8.2|
;;;77       {}
;;;78     }
;;;79     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;51       */
;;;52     void NMI_Handler(void)
000000  4770              BX       lr
;;;53     {
;;;54     }
;;;55     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;124      */
;;;125    void PendSV_Handler(void)
000000  4770              BX       lr
;;;126    {}
;;;127    
                          ENDP


                          AREA ||i.RTCAlarm_IRQHandler||, CODE, READONLY, ALIGN=1

                  RTCAlarm_IRQHandler PROC
;;;397    *******************************************************************************/
;;;398    void RTCAlarm_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;399    {
;;;400    
;;;401      if(RTC_GetITStatus(RTC_IT_ALR) != RESET)
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       RTC_GetITStatus
000008  b188              CBZ      r0,|L11.46|
;;;402      {
;;;403    	/* Clear EXTI line17 pending bit */
;;;404        EXTI_ClearITPendingBit(EXTI_Line17);
00000a  f44f3000          MOV      r0,#0x20000
00000e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;405    
;;;406        /* Check if the Wake-Up flag is set */
;;;407        if(PWR_GetFlagStatus(PWR_FLAG_WU) != RESET)
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       PWR_GetFlagStatus
000018  b110              CBZ      r0,|L11.32|
;;;408        {
;;;409          /* Clear Wake Up flag */
;;;410          PWR_ClearFlag(PWR_FLAG_WU);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       PWR_ClearFlag
                  |L11.32|
;;;411        }
;;;412    
;;;413        /* Wait until last write operation on RTC registers has finished */
;;;414        RTC_WaitForLastTask();   
000020  f7fffffe          BL       RTC_WaitForLastTask
;;;415        /* Clear RTC Alarm interrupt pending bit */
;;;416        RTC_ClearITPendingBit(RTC_IT_ALR);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RTC_ClearITPendingBit
;;;417        /* Wait until last write operation on RTC registers has finished */
;;;418        RTC_WaitForLastTask();
00002a  f7fffffe          BL       RTC_WaitForLastTask
                  |L11.46|
;;;419      }
;;;420    
;;;421    
;;;422    }
00002e  bd10              POP      {r4,pc}
;;;423    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;116      */
;;;117    void SVC_Handler(void)
000000  4770              BX       lr
;;;118    {}
;;;119    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;132      */
;;;133    void SysTick_Handler(void)
000000  4770              BX       lr
;;;134    {}
;;;135    
                          ENDP


                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;257    *******************************************************************************/
;;;258    void TIM3_IRQHandler(void)												/*刷卡中断响应函数*/
000000  b510              PUSH     {r4,lr}
;;;259    {
;;;260    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET) {
000002  2101              MOVS     r1,#1
000004  4807              LDR      r0,|L14.36|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2801              CMP      r0,#1
00000c  d109              BNE      |L14.34|
;;;261    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
00000e  2101              MOVS     r1,#1
000010  4804              LDR      r0,|L14.36|
000012  f7fffffe          BL       TIM_ClearITPendingBit
;;;262    		MSR_WaitForReady();												//刷卡完成
000016  f7fffffe          BL       MSR_WaitForReady
;;;263    		TIM_Cmd(TIM3, DISABLE);	
00001a  2100              MOVS     r1,#0
00001c  4801              LDR      r0,|L14.36|
00001e  f7fffffe          BL       TIM_Cmd
                  |L14.34|
;;;264    	}
;;;265    }
000022  bd10              POP      {r4,pc}
;;;266    
                          ENDP

                  |L14.36|
                          DCD      0x40000400

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;144    #if 1
;;;145    	void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147    	unsigned short ch;
;;;148    	
;;;149    	// 串口接收缓冲非空中断
;;;150    	//if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
;;;151    	if (((USART1->CR1 & 0x20) != 0) && ((USART1->SR & 0x20) != 0) ) {
000002  4947              LDR      r1,|L15.288|
000004  8809              LDRH     r1,[r1,#0]
000006  f0110f20          TST      r1,#0x20
00000a  d032              BEQ      |L15.114|
00000c  4944              LDR      r1,|L15.288|
00000e  390c              SUBS     r1,r1,#0xc
000010  8809              LDRH     r1,[r1,#0]
000012  f0110f20          TST      r1,#0x20
000016  d02c              BEQ      |L15.114|
;;;152    		//USART_ClearITPendingBit(USART1, USART_IT_RXNE);
;;;153    		USART1->SR = (u16)(~0x20);
000018  f64f71df          MOV      r1,#0xffdf
00001c  4a40              LDR      r2,|L15.288|
00001e  3a0c              SUBS     r2,r2,#0xc
000020  8011              STRH     r1,[r2,#0]
;;;154    		// if(USART_GetITStatus(USART1, USART_IT_ORE) != RESET)
;;;155    		if ( ((USART1->CR3 & 1) != 0) && ((USART1->SR & 0x8) != 0)) {
000022  493f              LDR      r1,|L15.288|
000024  3108              ADDS     r1,r1,#8
000026  8809              LDRH     r1,[r1,#0]
000028  f0110f01          TST      r1,#1
00002c  d00f              BEQ      |L15.78|
00002e  4611              MOV      r1,r2
000030  8809              LDRH     r1,[r1,#0]
000032  f0110f08          TST      r1,#8
000036  d00a              BEQ      |L15.78|
;;;156    			// 串口数据接收字符有丢失
;;;157    			// ch = USART_ReceiveData(USART1);
;;;158    			ch = (USART1->DR & (u16)0xFF);
000038  1d11              ADDS     r1,r2,#4
00003a  8809              LDRH     r1,[r1,#0]
00003c  b2c8              UXTB     r0,r1
;;;159    			// USART_GetITStatus(USART1, USART_IT_ORE); // 清除ORE标记
;;;160    			USART1->SR = (u16)(~0x8);
00003e  f64f71f7          MOV      r1,#0xfff7
000042  8011              STRH     r1,[r2,#0]
;;;161    			rec_end0 = rec_head0;
000044  4937              LDR      r1,|L15.292|
000046  8809              LDRH     r1,[r1,#0]  ; rec_head0
000048  4a37              LDR      r2,|L15.296|
00004a  8011              STRH     r1,[r2,#0]
00004c  e011              B        |L15.114|
                  |L15.78|
;;;162    		} else {
;;;163    			ch = USART1->DR;
00004e  4934              LDR      r1,|L15.288|
000050  3908              SUBS     r1,r1,#8
000052  8808              LDRH     r0,[r1,#0]
;;;164    			//USART_SendData(USART1, ch);
;;;165    			rec_buf0[rec_end0++] = (unsigned char)(ch&0xff);
000054  4a34              LDR      r2,|L15.296|
000056  8811              LDRH     r1,[r2,#0]  ; rec_end0
000058  1c4a              ADDS     r2,r1,#1
00005a  4c33              LDR      r4,|L15.296|
00005c  8022              STRH     r2,[r4,#0]
00005e  4a33              LDR      r2,|L15.300|
000060  5450              STRB     r0,[r2,r1]
;;;166    			if (rec_end0 >= RXTEMPBUFLENMAX) {
000062  4621              MOV      r1,r4
000064  8809              LDRH     r1,[r1,#0]  ; rec_end0
000066  f5b17f00          CMP      r1,#0x200
00006a  db02              BLT      |L15.114|
;;;167    				rec_end0 = 0;
00006c  2100              MOVS     r1,#0
00006e  4622              MOV      r2,r4
000070  8011              STRH     r1,[r2,#0]
                  |L15.114|
;;;168    			}
;;;169    
;;;170    		}
;;;171    	}
;;;172    
;;;173    	/* If a Frame error is signaled by the card */
;;;174    	// if(USART_GetITStatus(USART1, USART_IT_FE) != RESET)
;;;175    	if( ((USART1->CR3 & 1) != 0) && 
000072  492b              LDR      r1,|L15.288|
000074  3108              ADDS     r1,r1,#8
000076  8809              LDRH     r1,[r1,#0]
000078  f0110f01          TST      r1,#1
00007c  d00d              BEQ      |L15.154|
;;;176    		((USART1->SR & 0x2) != 0) )
00007e  4928              LDR      r1,|L15.288|
000080  390c              SUBS     r1,r1,#0xc
000082  8809              LDRH     r1,[r1,#0]
000084  f0110f02          TST      r1,#2
000088  d007              BEQ      |L15.154|
;;;177    	{
;;;178    		/* Clear the USART1 Frame error pending bit */
;;;179    		// USART_ClearITPendingBit(USART1, USART_IT_FE);
;;;180    		USART1->SR = (u16)(~2);
00008a  f64f71fd          MOV      r1,#0xfffd
00008e  4a24              LDR      r2,|L15.288|
000090  3a0c              SUBS     r2,r2,#0xc
000092  8011              STRH     r1,[r2,#0]
;;;181    		// USART_ReceiveData(USART1);
;;;182    		ch = (USART1->DR & (u16)0xFF);
000094  1d11              ADDS     r1,r2,#4
000096  8809              LDRH     r1,[r1,#0]
000098  b2c8              UXTB     r0,r1
                  |L15.154|
;;;183    		/* Resend the byte that failed to be received (by the Smartcard) correctly */
;;;184    		//SC_ParityErrorHandler();
;;;185    	}
;;;186    
;;;187    	/* If the USART1 detects a parity error */
;;;188    	// if(USART_GetITStatus(USART1, USART_IT_PE) != RESET)
;;;189    	if( ((USART1->CR1 & 0x100) != 0) && 
00009a  4921              LDR      r1,|L15.288|
00009c  8809              LDRH     r1,[r1,#0]
00009e  f4117f80          TST      r1,#0x100
0000a2  d014              BEQ      |L15.206|
;;;190    		((USART1->SR & 1) != 0) )
0000a4  491e              LDR      r1,|L15.288|
0000a6  390c              SUBS     r1,r1,#0xc
0000a8  8809              LDRH     r1,[r1,#0]
0000aa  f0110f01          TST      r1,#1
0000ae  d00e              BEQ      |L15.206|
;;;191    	{
;;;192    		// while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
;;;193    		while((USART1->SR & USART_FLAG_RXNE) == 0)
0000b0  bf00              NOP      
                  |L15.178|
0000b2  491b              LDR      r1,|L15.288|
0000b4  390c              SUBS     r1,r1,#0xc
0000b6  8809              LDRH     r1,[r1,#0]
0000b8  f0110f20          TST      r1,#0x20
0000bc  d0f9              BEQ      |L15.178|
;;;194    		{
;;;195    		}
;;;196    		/* Clear the USART1 Parity error pending bit */
;;;197    		// USART_ClearITPendingBit(USART1, USART_IT_PE);
;;;198    		USART1->SR = (u16)(~1);
0000be  f64f71fe          MOV      r1,#0xfffe
0000c2  4a17              LDR      r2,|L15.288|
0000c4  3a0c              SUBS     r2,r2,#0xc
0000c6  8011              STRH     r1,[r2,#0]
;;;199    		// USART_ReceiveData(USART1);
;;;200    		ch = (USART1->DR & (u16)0xFF);
0000c8  1d11              ADDS     r1,r2,#4
0000ca  8809              LDRH     r1,[r1,#0]
0000cc  b2c8              UXTB     r0,r1
                  |L15.206|
;;;201    	}
;;;202    	/* If a Overrun error is signaled by the card */
;;;203    	// if(USART_GetITStatus(USART1, USART_IT_ORE) != RESET)
;;;204    	if( ((USART1->CR3 & 1) != 0) && 
0000ce  4914              LDR      r1,|L15.288|
0000d0  3108              ADDS     r1,r1,#8
0000d2  8809              LDRH     r1,[r1,#0]
0000d4  f0110f01          TST      r1,#1
0000d8  d00d              BEQ      |L15.246|
;;;205    		((USART1->SR & 0x8) != 0) )
0000da  4911              LDR      r1,|L15.288|
0000dc  390c              SUBS     r1,r1,#0xc
0000de  8809              LDRH     r1,[r1,#0]
0000e0  f0110f08          TST      r1,#8
0000e4  d007              BEQ      |L15.246|
;;;206    	{
;;;207    		/* Clear the USART1 Frame error pending bit */
;;;208    		// USART_ClearITPendingBit(USART1, USART_IT_ORE);
;;;209    		USART1->SR = (u16)(~0x8);
0000e6  f64f71f7          MOV      r1,#0xfff7
0000ea  4a0d              LDR      r2,|L15.288|
0000ec  3a0c              SUBS     r2,r2,#0xc
0000ee  8011              STRH     r1,[r2,#0]
;;;210    		// USART_ReceiveData(USART1);
;;;211    		ch = (USART1->DR &(u16)0xFF);
0000f0  1d11              ADDS     r1,r2,#4
0000f2  8809              LDRH     r1,[r1,#0]
0000f4  b2c8              UXTB     r0,r1
                  |L15.246|
;;;212    	}
;;;213    	/* If a Noise error is signaled by the card */
;;;214    	// if(USART_GetITStatus(USART1, USART_IT_NE) != RESET)
;;;215    	if( ((USART1->CR3 & 1) != 0) && 
0000f6  490a              LDR      r1,|L15.288|
0000f8  3108              ADDS     r1,r1,#8
0000fa  8809              LDRH     r1,[r1,#0]
0000fc  f0110f01          TST      r1,#1
000100  d00d              BEQ      |L15.286|
;;;216    		((USART1->SR & 0x4) != 0) )
000102  4907              LDR      r1,|L15.288|
000104  390c              SUBS     r1,r1,#0xc
000106  8809              LDRH     r1,[r1,#0]
000108  f0110f04          TST      r1,#4
00010c  d007              BEQ      |L15.286|
;;;217    	{
;;;218    		/* Clear the USART1 Frame error pending bit */
;;;219    		// USART_ClearITPendingBit(USART1, USART_IT_NE);
;;;220    		USART1->SR = (u16)(~4);
00010e  f64f71fb          MOV      r1,#0xfffb
000112  4a03              LDR      r2,|L15.288|
000114  3a0c              SUBS     r2,r2,#0xc
000116  8011              STRH     r1,[r2,#0]
;;;221    		// USART_ReceiveData(USART1);
;;;222    		ch = (USART1->DR &(u16)0xFF);
000118  1d11              ADDS     r1,r2,#4
00011a  8809              LDRH     r1,[r1,#0]
00011c  b2c8              UXTB     r0,r1
                  |L15.286|
;;;223    	}
;;;224    }
00011e  bd10              POP      {r4,pc}
;;;225    #endif
                          ENDP

                  |L15.288|
                          DCD      0x4001380c
                  |L15.292|
                          DCD      rec_head0
                  |L15.296|
                          DCD      rec_end0
                  |L15.300|
                          DCD      Track1TimeFlow

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;96       */
;;;97     void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L16.2|
;;;98     {
;;;99       /* Go to infinite loop when Usage Fault exception occurs */
;;;100      while (1)
000002  e7fe              B        |L16.2|
;;;101      {}
;;;102    }
;;;103    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  TM1ReadValue1
000000  0000              DCW      0x0000
                  TM1ReadValue2
000002  0000              DCW      0x0000
                  TM2ReadValue1
000004  0000              DCW      0x0000
                  TM2ReadValue2
000006  0000              DCW      0x0000
                  TM3ReadValue1
000008  0000              DCW      0x0000
                  TM3ReadValue2
00000a  0000              DCW      0x0000
                  TM1CaptureNumber
00000c  00                DCB      0x00
                  TM2CaptureNumber
00000d  00                DCB      0x00
                  TM3CaptureNumber
00000e  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\dev\\stm32f10x_it.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_5dd9ab25____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f10x_it_c_5dd9ab25____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_5dd9ab25____REVSH|
#line 144
|__asm___14_stm32f10x_it_c_5dd9ab25____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
