; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dev_msread.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dev_msread.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\user -I..\dev -I..\lib\inc -I..\core_cm3 -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\dev_msread.crf ..\dev\dev_msread.c]
                          THUMB

                          AREA ||i.MSR_SendData||, CODE, READONLY, ALIGN=2

                  MSR_SendData PROC
;;;30     ***************************************************************************************/
;;;31     void MSR_SendData(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;32     {
000004  b08b              SUB      sp,sp,#0x2c
;;;33     	uint8_t *ch = (uint8_t *)TrackBitFlow.Value, ivec[16];
000006  4cfe              LDR      r4,|L1.1024|
;;;34     	uint16_t len = 0x10,j;
000008  f04f0810          MOV      r8,#0x10
;;;35     	uint8_t lrc,bcc,block1,block2,block3;
;;;36     		
;;;37     	if(ENC_KEY.temp.level < 0x30 && ENC_KEY.temp.level > 0x34 )	//加密级别失效
00000c  48fd              LDR      r0,|L1.1028|
00000e  7840              LDRB     r0,[r0,#1]  ; ENC_KEY
000010  2830              CMP      r0,#0x30
000012  da04              BGE      |L1.30|
000014  48fb              LDR      r0,|L1.1028|
000016  7840              LDRB     r0,[r0,#1]  ; ENC_KEY
000018  2834              CMP      r0,#0x34
00001a  dd00              BLE      |L1.30|
;;;38     	{
;;;39     		goto ERRORDATA;											//密钥失效返回错误
00001c  e330              B        |L1.1664|
                  |L1.30|
;;;40     	}
;;;41     	if (1 == ENC_KEY.temp.status)								//密文回送磁道数据
00001e  48f9              LDR      r0,|L1.1028|
000020  7800              LDRB     r0,[r0,#0]  ; ENC_KEY
000022  2801              CMP      r0,#1
000024  d17d              BNE      |L1.290|
;;;42     	{
;;;43     		encryptdatastatus = 0xBF;								//设置返回数据的类型
000026  20bf              MOVS     r0,#0xbf
000028  49f7              LDR      r1,|L1.1032|
00002a  7008              STRB     r0,[r1,#0]
;;;44     				
;;;45     		/*长度加84 = 11个数据包头 + 60 个哈希值 + 10个KSN + 2个校验码 + 1个包结束 */
;;;46     		if(0x32 == ENC_KEY.temp.encway)							//如果AES加密则每块16字节
00002c  48f5              LDR      r0,|L1.1028|
00002e  78c0              LDRB     r0,[r0,#3]  ; ENC_KEY
000030  2832              CMP      r0,#0x32
000032  d147              BNE      |L1.196|
;;;47     		{
;;;48     			block1 = ceil((TK1len-1)/16.0);
000034  49f5              LDR      r1,|L1.1036|
000036  f891106e          LDRB     r1,[r1,#0x6e]  ; Track1Data
00003a  1e48              SUBS     r0,r1,#1
00003c  f7fffffe          BL       __aeabi_i2d
000040  2200              MOVS     r2,#0
000042  4bf3              LDR      r3,|L1.1040|
000044  e9cd0100          STRD     r0,r1,[sp,#0]
000048  f7fffffe          BL       __aeabi_ddiv
00004c  e9cd0102          STRD     r0,r1,[sp,#8]
000050  f7fffffe          BL       ceil
000054  e9cd0104          STRD     r0,r1,[sp,#0x10]
000058  f7fffffe          BL       __aeabi_d2uiz
00005c  b2c6              UXTB     r6,r0
;;;49     			block2 = ceil((TK2len-1)/16.0);
00005e  49ed              LDR      r1,|L1.1044|
000060  f891106e          LDRB     r1,[r1,#0x6e]  ; Track2Data
000064  1e48              SUBS     r0,r1,#1
000066  f7fffffe          BL       __aeabi_i2d
00006a  2200              MOVS     r2,#0
00006c  4be8              LDR      r3,|L1.1040|
00006e  e9cd0100          STRD     r0,r1,[sp,#0]
000072  f7fffffe          BL       __aeabi_ddiv
000076  e9cd0102          STRD     r0,r1,[sp,#8]
00007a  f7fffffe          BL       ceil
00007e  e9cd0104          STRD     r0,r1,[sp,#0x10]
000082  f7fffffe          BL       __aeabi_d2uiz
000086  b2c7              UXTB     r7,r0
;;;50     			block3 = ceil((TK3len-1)/16.0);
000088  49e3              LDR      r1,|L1.1048|
00008a  f891106e          LDRB     r1,[r1,#0x6e]  ; Track3Data
00008e  1e48              SUBS     r0,r1,#1
000090  f7fffffe          BL       __aeabi_i2d
000094  2200              MOVS     r2,#0
000096  4bde              LDR      r3,|L1.1040|
000098  e9cd0100          STRD     r0,r1,[sp,#0]
00009c  f7fffffe          BL       __aeabi_ddiv
0000a0  e9cd0102          STRD     r0,r1,[sp,#8]
0000a4  f7fffffe          BL       ceil
0000a8  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000ac  f7fffffe          BL       __aeabi_d2uiz
0000b0  f00009ff          AND      r9,r0,#0xff
;;;51     			len = block1*16 + block2*16 + block3*16 + 84 ;		//计算返回数据长度
0000b4  0130              LSLS     r0,r6,#4
0000b6  eb001007          ADD      r0,r0,r7,LSL #4
0000ba  eb001009          ADD      r0,r0,r9,LSL #4
0000be  f1000854          ADD      r8,r0,#0x54
0000c2  e048              B        |L1.342|
                  |L1.196|
;;;52     		}
;;;53     		else													//如果DES加密则每块8字节
;;;54     		{
;;;55     			block1 = ceil((TK1len-1)/8.0);
0000c4  49d1              LDR      r1,|L1.1036|
0000c6  f891106e          LDRB     r1,[r1,#0x6e]  ; Track1Data
0000ca  1e48              SUBS     r0,r1,#1
0000cc  f7fffffe          BL       __aeabi_i2d
0000d0  2200              MOVS     r2,#0
0000d2  4bd2              LDR      r3,|L1.1052|
0000d4  e9cd0100          STRD     r0,r1,[sp,#0]
0000d8  f7fffffe          BL       __aeabi_ddiv
0000dc  e9cd0102          STRD     r0,r1,[sp,#8]
0000e0  f7fffffe          BL       ceil
0000e4  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000e8  f7fffffe          BL       __aeabi_d2uiz
0000ec  b2c6              UXTB     r6,r0
;;;56     			block2 = ceil((TK2len-1)/8.0);
0000ee  49c9              LDR      r1,|L1.1044|
0000f0  f891106e          LDRB     r1,[r1,#0x6e]  ; Track2Data
0000f4  1e48              SUBS     r0,r1,#1
0000f6  f7fffffe          BL       __aeabi_i2d
0000fa  2200              MOVS     r2,#0
0000fc  4bc7              LDR      r3,|L1.1052|
0000fe  e9cd0100          STRD     r0,r1,[sp,#0]
000102  f7fffffe          BL       __aeabi_ddiv
000106  e9cd0102          STRD     r0,r1,[sp,#8]
00010a  f7fffffe          BL       ceil
00010e  e9cd0104          STRD     r0,r1,[sp,#0x10]
000112  f7fffffe          BL       __aeabi_d2uiz
000116  b2c7              UXTB     r7,r0
;;;57     			block3 = ceil((TK3len-1)/8.0);
000118  49bf              LDR      r1,|L1.1048|
00011a  f891106e          LDRB     r1,[r1,#0x6e]  ; Track3Data
00011e  1e48              SUBS     r0,r1,#1
000120  e000              B        |L1.292|
                  |L1.290|
000122  e248              B        |L1.1462|
                  |L1.292|
000124  f7fffffe          BL       __aeabi_i2d
000128  2200              MOVS     r2,#0
00012a  4bbc              LDR      r3,|L1.1052|
00012c  e9cd0100          STRD     r0,r1,[sp,#0]
000130  f7fffffe          BL       __aeabi_ddiv
000134  e9cd0102          STRD     r0,r1,[sp,#8]
000138  f7fffffe          BL       ceil
00013c  e9cd0104          STRD     r0,r1,[sp,#0x10]
000140  f7fffffe          BL       __aeabi_d2uiz
000144  f00009ff          AND      r9,r0,#0xff
;;;58     			len = block1*8 + block2*8 + block3*8 + 84 ;  		//计算返回数据长度
000148  00f0              LSLS     r0,r6,#3
00014a  eb0000c7          ADD      r0,r0,r7,LSL #3
00014e  eb0000c9          ADD      r0,r0,r9,LSL #3
000152  f1000854          ADD      r8,r0,#0x54
                  |L1.342|
;;;59     		}
;;;60     		
;;;61     		if(!block1 && !block2 && !block3)						//如果所有磁道数为空，刷卡失败
000156  b926              CBNZ     r6,|L1.354|
000158  b91f              CBNZ     r7,|L1.354|
00015a  f1b90f00          CMP      r9,#0
00015e  d100              BNE      |L1.354|
;;;62     			goto ERRORDATA;
000160  e28e              B        |L1.1664|
                  |L1.354|
;;;63     		if(!TK1len)
000162  48aa              LDR      r0,|L1.1036|
000164  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
000168  b950              CBNZ     r0,|L1.384|
;;;64     		{												   	
;;;65     			encryptdatastatus &= 0xF6;							//第一磁道数据返回为空
00016a  48a7              LDR      r0,|L1.1032|
00016c  7800              LDRB     r0,[r0,#0]  ; encryptdatastatus
00016e  f00000f6          AND      r0,r0,#0xf6
000172  49a5              LDR      r1,|L1.1032|
000174  7008              STRB     r0,[r1,#0]
;;;66     			len -= 20;
000176  f1a80014          SUB      r0,r8,#0x14
00017a  fa1ff880          UXTH     r8,r0
00017e  e00f              B        |L1.416|
                  |L1.384|
;;;67     		}
;;;68     		else
;;;69     		{
;;;70     			SHA1Init (&foo);
000180  48a7              LDR      r0,|L1.1056|
000182  f7fffffe          BL       SHA1Init
;;;71     			SHA1Update (&foo, &TK1buf[1], TK1len-1);			//计算第一磁道数据哈希值
000186  48a1              LDR      r0,|L1.1036|
000188  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
00018c  1e42              SUBS     r2,r0,#1
00018e  499f              LDR      r1,|L1.1036|
000190  1c49              ADDS     r1,r1,#1
000192  48a3              LDR      r0,|L1.1056|
000194  f7fffffe          BL       SHA1Update
;;;72     			SHA1Final (&foo, sha);
000198  49a2              LDR      r1,|L1.1060|
00019a  48a1              LDR      r0,|L1.1056|
00019c  f7fffffe          BL       SHA1Final
                  |L1.416|
;;;73     		}
;;;74     		if(!TK2len)
0001a0  489c              LDR      r0,|L1.1044|
0001a2  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
0001a6  b950              CBNZ     r0,|L1.446|
;;;75     		{
;;;76     			encryptdatastatus &= 0xED;							//第二磁道数据返回为空
0001a8  4897              LDR      r0,|L1.1032|
0001aa  7800              LDRB     r0,[r0,#0]  ; encryptdatastatus
0001ac  f00000ed          AND      r0,r0,#0xed
0001b0  4995              LDR      r1,|L1.1032|
0001b2  7008              STRB     r0,[r1,#0]
;;;77     			len -= 20;
0001b4  f1a80014          SUB      r0,r8,#0x14
0001b8  fa1ff880          UXTH     r8,r0
0001bc  e010              B        |L1.480|
                  |L1.446|
;;;78     		}
;;;79     		else
;;;80     		{
;;;81     			SHA1Init (&foo);
0001be  4898              LDR      r0,|L1.1056|
0001c0  f7fffffe          BL       SHA1Init
;;;82     			SHA1Update (&foo, &TK2buf[1], TK2len-1);			//计算第二磁道数据哈希值
0001c4  4893              LDR      r0,|L1.1044|
0001c6  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
0001ca  1e42              SUBS     r2,r0,#1
0001cc  4991              LDR      r1,|L1.1044|
0001ce  1c49              ADDS     r1,r1,#1
0001d0  4893              LDR      r0,|L1.1056|
0001d2  f7fffffe          BL       SHA1Update
;;;83     			SHA1Final (&foo, sha+20);
0001d6  4993              LDR      r1,|L1.1060|
0001d8  3114              ADDS     r1,r1,#0x14
0001da  4891              LDR      r0,|L1.1056|
0001dc  f7fffffe          BL       SHA1Final
                  |L1.480|
;;;84     		}
;;;85     		if(!TK3len)
0001e0  488d              LDR      r0,|L1.1048|
0001e2  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
0001e6  b950              CBNZ     r0,|L1.510|
;;;86     		{
;;;87     		 	encryptdatastatus &= 0xDB;							//第三磁道数据返回为空
0001e8  4887              LDR      r0,|L1.1032|
0001ea  7800              LDRB     r0,[r0,#0]  ; encryptdatastatus
0001ec  f00000db          AND      r0,r0,#0xdb
0001f0  4985              LDR      r1,|L1.1032|
0001f2  7008              STRB     r0,[r1,#0]
;;;88     			len -= 20;
0001f4  f1a80014          SUB      r0,r8,#0x14
0001f8  fa1ff880          UXTH     r8,r0
0001fc  e010              B        |L1.544|
                  |L1.510|
;;;89     		}
;;;90     		else
;;;91     		{
;;;92     			SHA1Init (&foo);
0001fe  4888              LDR      r0,|L1.1056|
000200  f7fffffe          BL       SHA1Init
;;;93     			SHA1Update (&foo, &TK3buf[1], TK3len-1);			//计算第三磁道数据哈希值
000204  4884              LDR      r0,|L1.1048|
000206  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
00020a  1e42              SUBS     r2,r0,#1
00020c  4982              LDR      r1,|L1.1048|
00020e  1c49              ADDS     r1,r1,#1
000210  4883              LDR      r0,|L1.1056|
000212  f7fffffe          BL       SHA1Update
;;;94     			SHA1Final (&foo, sha+40);
000216  4983              LDR      r1,|L1.1060|
000218  3128              ADDS     r1,r1,#0x28
00021a  4881              LDR      r0,|L1.1056|
00021c  f7fffffe          BL       SHA1Final
                  |L1.544|
;;;95     		}		 
;;;96     								
;;;97     		memcpy(ch,"\xFF\x02\x00\x00\x80\x3F\x00\x00\x00\x00",10);//10个字节数据包头
000220  a081              ADR      r0,|L1.1064|
000222  6801              LDR      r1,[r0,#0]
000224  6021              STR      r1,[r4,#0]
000226  6841              LDR      r1,[r0,#4]
000228  6061              STR      r1,[r4,#4]
00022a  8900              LDRH     r0,[r0,#8]
00022c  8120              STRH     r0,[r4,#8]
;;;98     		ch[2] = (uint8_t)(len-7);								 //保存长度
00022e  f1a80007          SUB      r0,r8,#7
000232  70a0              STRB     r0,[r4,#2]
;;;99     		ch[3] = ((len-7)>>8);
000234  0a00              LSRS     r0,r0,#8
000236  70e0              STRB     r0,[r4,#3]
;;;100    		if(TK1len)ch[6] = TK1len-1;
000238  4874              LDR      r0,|L1.1036|
00023a  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
00023e  b120              CBZ      r0,|L1.586|
000240  4872              LDR      r0,|L1.1036|
000242  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
000246  1e40              SUBS     r0,r0,#1
000248  71a0              STRB     r0,[r4,#6]
                  |L1.586|
;;;101    		if(!TK1len)ch[5] = 0x37;
00024a  4870              LDR      r0,|L1.1036|
00024c  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
000250  b908              CBNZ     r0,|L1.598|
000252  2037              MOVS     r0,#0x37
000254  7160              STRB     r0,[r4,#5]
                  |L1.598|
;;;102    		if(TK2len)ch[7] = TK2len-1;
000256  486f              LDR      r0,|L1.1044|
000258  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
00025c  b120              CBZ      r0,|L1.616|
00025e  486d              LDR      r0,|L1.1044|
000260  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
000264  1e40              SUBS     r0,r0,#1
000266  71e0              STRB     r0,[r4,#7]
                  |L1.616|
;;;103    		if(TK3len)ch[8] = TK3len-1;
000268  486b              LDR      r0,|L1.1048|
00026a  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
00026e  b120              CBZ      r0,|L1.634|
000270  4869              LDR      r0,|L1.1048|
000272  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
000276  1e40              SUBS     r0,r0,#1
000278  7220              STRB     r0,[r4,#8]
                  |L1.634|
;;;104    		ch[10] = encryptdatastatus;								//返回数据类型
00027a  4863              LDR      r0,|L1.1032|
00027c  7800              LDRB     r0,[r0,#0]  ; encryptdatastatus
00027e  72a0              STRB     r0,[r4,#0xa]
;;;105    		
;;;106    		if (0x31 == ENC_KEY.temp.encmode)				   		//DUKPT加密
000280  4860              LDR      r0,|L1.1028|
000282  7880              LDRB     r0,[r0,#2]  ; ENC_KEY
000284  2831              CMP      r0,#0x31
000286  d102              BNE      |L1.654|
;;;107    		{
;;;108    			CalcCryptoKey();									//计算DUKPT过程密钥
000288  f7fffffe          BL       CalcCryptoKey
00028c  e009              B        |L1.674|
                  |L1.654|
;;;109    		}
;;;110    		else if (0x30 == ENC_KEY.temp.encmode)			 		//FIX加密
00028e  485d              LDR      r0,|L1.1028|
000290  7880              LDRB     r0,[r0,#2]  ; ENC_KEY
000292  2830              CMP      r0,#0x30
000294  d105              BNE      |L1.674|
;;;111    		{
;;;112    			memcpy(CryptoKey,ENC_KEY.temp.fix,16);				//拷贝FIX密钥
000296  2210              MOVS     r2,#0x10
000298  495a              LDR      r1,|L1.1028|
00029a  1d09              ADDS     r1,r1,#4
00029c  4865              LDR      r0,|L1.1076|
00029e  f7fffffe          BL       __aeabi_memcpy
                  |L1.674|
;;;113    		}
;;;114    		if( 0x30 == ENC_KEY.temp.encway)						//DES加密
0002a2  4858              LDR      r0,|L1.1028|
0002a4  78c0              LDRB     r0,[r0,#3]  ; ENC_KEY
0002a6  2830              CMP      r0,#0x30
0002a8  d100              BNE      |L1.684|
;;;115    		{
;;;116    			goto ERRORDATA;
0002aa  e1e9              B        |L1.1664|
                  |L1.684|
;;;117    		}
;;;118    		else if(0x31 == ENC_KEY.temp.encway)					//3DES加密
0002ac  4855              LDR      r0,|L1.1028|
0002ae  78c0              LDRB     r0,[r0,#3]  ; ENC_KEY
0002b0  2831              CMP      r0,#0x31
0002b2  d17d              BNE      |L1.944|
;;;119    		{
;;;120    			tri_des(TK1buf+1,CryptoKey,CryptoKey+8,0);
0002b4  2300              MOVS     r3,#0
0002b6  4a5f              LDR      r2,|L1.1076|
0002b8  3208              ADDS     r2,r2,#8
0002ba  495e              LDR      r1,|L1.1076|
0002bc  4853              LDR      r0,|L1.1036|
0002be  1c40              ADDS     r0,r0,#1
0002c0  f7fffffe          BL       tri_des
;;;121    			for(j = 1;j< block1;j++)							//加密第一磁道数据
0002c4  2501              MOVS     r5,#1
0002c6  e016              B        |L1.758|
                  |L1.712|
;;;122    			{
;;;123    				xor(TK1buf+1+j*8,TK1buf+j*8-7,8);
0002c8  4a50              LDR      r2,|L1.1036|
0002ca  eb0202c5          ADD      r2,r2,r5,LSL #3
0002ce  1fd1              SUBS     r1,r2,#7
0002d0  4a4e              LDR      r2,|L1.1036|
0002d2  1c52              ADDS     r2,r2,#1
0002d4  eb0200c5          ADD      r0,r2,r5,LSL #3
0002d8  2208              MOVS     r2,#8
0002da  f7fffffe          BL       xor
;;;124    				tri_des(TK1buf+1+j*8,CryptoKey,CryptoKey+8,0);
0002de  494b              LDR      r1,|L1.1036|
0002e0  1c49              ADDS     r1,r1,#1
0002e2  eb0100c5          ADD      r0,r1,r5,LSL #3
0002e6  2300              MOVS     r3,#0
0002e8  4a52              LDR      r2,|L1.1076|
0002ea  3208              ADDS     r2,r2,#8
0002ec  4951              LDR      r1,|L1.1076|
0002ee  f7fffffe          BL       tri_des
0002f2  1c68              ADDS     r0,r5,#1              ;121
0002f4  b285              UXTH     r5,r0                 ;121
                  |L1.758|
0002f6  42b5              CMP      r5,r6                 ;121
0002f8  dbe6              BLT      |L1.712|
;;;125    			}
;;;126    			memcpy(ch+11,TK1buf+1,block1*8);
0002fa  00f2              LSLS     r2,r6,#3
0002fc  4943              LDR      r1,|L1.1036|
0002fe  1c49              ADDS     r1,r1,#1
000300  f104000b          ADD      r0,r4,#0xb
000304  f7fffffe          BL       __aeabi_memcpy
;;;127    
;;;128    			tri_des(TK2buf+1,CryptoKey,CryptoKey+8,0);
000308  2300              MOVS     r3,#0
00030a  4a4a              LDR      r2,|L1.1076|
00030c  3208              ADDS     r2,r2,#8
00030e  4949              LDR      r1,|L1.1076|
000310  4840              LDR      r0,|L1.1044|
000312  1c40              ADDS     r0,r0,#1
000314  f7fffffe          BL       tri_des
;;;129    			for(j = 1;j< block2;j++)							//加密第二磁道数据
000318  2501              MOVS     r5,#1
00031a  e016              B        |L1.842|
                  |L1.796|
;;;130    			{
;;;131    				xor(TK2buf+1+j*8,TK2buf+j*8-7,8);
00031c  4a3d              LDR      r2,|L1.1044|
00031e  eb0202c5          ADD      r2,r2,r5,LSL #3
000322  1fd1              SUBS     r1,r2,#7
000324  4a3b              LDR      r2,|L1.1044|
000326  1c52              ADDS     r2,r2,#1
000328  eb0200c5          ADD      r0,r2,r5,LSL #3
00032c  2208              MOVS     r2,#8
00032e  f7fffffe          BL       xor
;;;132    				tri_des(TK2buf+1+j*8,CryptoKey,CryptoKey+8,0);
000332  4938              LDR      r1,|L1.1044|
000334  1c49              ADDS     r1,r1,#1
000336  eb0100c5          ADD      r0,r1,r5,LSL #3
00033a  2300              MOVS     r3,#0
00033c  4a3d              LDR      r2,|L1.1076|
00033e  3208              ADDS     r2,r2,#8
000340  493c              LDR      r1,|L1.1076|
000342  f7fffffe          BL       tri_des
000346  1c68              ADDS     r0,r5,#1              ;129
000348  b285              UXTH     r5,r0                 ;129
                  |L1.842|
00034a  42bd              CMP      r5,r7                 ;129
00034c  dbe6              BLT      |L1.796|
;;;133    			}
;;;134    			memcpy(ch+11+block1*8,TK2buf+1,block2*8);
00034e  00fa              LSLS     r2,r7,#3
000350  f104010b          ADD      r1,r4,#0xb
000354  eb0100c6          ADD      r0,r1,r6,LSL #3
000358  492e              LDR      r1,|L1.1044|
00035a  1c49              ADDS     r1,r1,#1
00035c  f7fffffe          BL       __aeabi_memcpy
;;;135    			
;;;136    			tri_des(TK3buf+1,CryptoKey,CryptoKey+8,0);
000360  2300              MOVS     r3,#0
000362  4a34              LDR      r2,|L1.1076|
000364  3208              ADDS     r2,r2,#8
000366  4933              LDR      r1,|L1.1076|
000368  482b              LDR      r0,|L1.1048|
00036a  1c40              ADDS     r0,r0,#1
00036c  f7fffffe          BL       tri_des
;;;137    			for(j = 1;j< block3;j++)							//加密第三磁道数据
000370  2501              MOVS     r5,#1
000372  e016              B        |L1.930|
                  |L1.884|
;;;138    			{
;;;139    				xor(TK3buf+1+j*8,TK3buf+j*8-7,8);
000374  4a28              LDR      r2,|L1.1048|
000376  eb0202c5          ADD      r2,r2,r5,LSL #3
00037a  1fd1              SUBS     r1,r2,#7
00037c  4a26              LDR      r2,|L1.1048|
00037e  1c52              ADDS     r2,r2,#1
000380  eb0200c5          ADD      r0,r2,r5,LSL #3
000384  2208              MOVS     r2,#8
000386  f7fffffe          BL       xor
;;;140    				tri_des(TK3buf+1+j*8,CryptoKey,CryptoKey+8,0);
00038a  4923              LDR      r1,|L1.1048|
00038c  1c49              ADDS     r1,r1,#1
00038e  eb0100c5          ADD      r0,r1,r5,LSL #3
000392  2300              MOVS     r3,#0
000394  4a27              LDR      r2,|L1.1076|
000396  3208              ADDS     r2,r2,#8
000398  4926              LDR      r1,|L1.1076|
00039a  f7fffffe          BL       tri_des
00039e  1c68              ADDS     r0,r5,#1              ;137
0003a0  b285              UXTH     r5,r0                 ;137
                  |L1.930|
0003a2  454d              CMP      r5,r9                 ;137
0003a4  dbe6              BLT      |L1.884|
;;;141    			}
;;;142    			memcpy(ch+11+block1*8+block2*8,TK3buf+1,block3*8);
0003a6  f104010b          ADD      r1,r4,#0xb
0003aa  eb0101c6          ADD      r1,r1,r6,LSL #3
0003ae  e000              B        |L1.946|
                  |L1.944|
0003b0  e008              B        |L1.964|
                  |L1.946|
0003b2  eb0100c7          ADD      r0,r1,r7,LSL #3
0003b6  ea4f02c9          LSL      r2,r9,#3
0003ba  4917              LDR      r1,|L1.1048|
0003bc  1c49              ADDS     r1,r1,#1
0003be  f7fffffe          BL       __aeabi_memcpy
0003c2  e082              B        |L1.1226|
                  |L1.964|
;;;143    		}
;;;144    		else if(0x32 == ENC_KEY.temp.encway)					//AES加密
0003c4  480f              LDR      r0,|L1.1028|
0003c6  78c0              LDRB     r0,[r0,#3]  ; ENC_KEY
0003c8  2832              CMP      r0,#0x32
0003ca  d17d              BNE      |L1.1224|
;;;145    		{
;;;146    			AES_set_encrypt_key(CryptoKey,128,&key);
0003cc  4a1a              LDR      r2,|L1.1080|
0003ce  2180              MOVS     r1,#0x80
0003d0  4818              LDR      r0,|L1.1076|
0003d2  f7fffffe          BL       AES_set_encrypt_key
;;;147    			/* 加密第一磁道数据 */
;;;148    			if(block1)
0003d6  b196              CBZ      r6,|L1.1022|
;;;149    			{
;;;150    				memset(ivec,0,sizeof(ivec));
0003d8  2000              MOVS     r0,#0
0003da  9006              STR      r0,[sp,#0x18]
0003dc  9007              STR      r0,[sp,#0x1c]
0003de  9008              STR      r0,[sp,#0x20]
0003e0  9009              STR      r0,[sp,#0x24]
;;;151    				memcpy(ch+11,TK1buf+1,block1*16);
0003e2  0132              LSLS     r2,r6,#4
0003e4  4909              LDR      r1,|L1.1036|
0003e6  1c49              ADDS     r1,r1,#1
0003e8  f104000b          ADD      r0,r4,#0xb
0003ec  f7fffffe          BL       __aeabi_memcpy
;;;152    				AES_cbc_encrypt(ch+11,ch+11,block1*16,&key,ivec,1);
0003f0  2001              MOVS     r0,#1
0003f2  a906              ADD      r1,sp,#0x18
0003f4  0132              LSLS     r2,r6,#4
0003f6  4b10              LDR      r3,|L1.1080|
0003f8  e9cd1000          STRD     r1,r0,[sp,#0]
0003fc  e01e              B        |L1.1084|
                  |L1.1022|
0003fe  e022              B        |L1.1094|
                  |L1.1024|
                          DCD      TrackBitFlow
                  |L1.1028|
                          DCD      ENC_KEY
                  |L1.1032|
                          DCD      encryptdatastatus
                  |L1.1036|
                          DCD      Track1Data
                  |L1.1040|
                          DCD      0x40300000
                  |L1.1044|
                          DCD      Track2Data
                  |L1.1048|
                          DCD      Track3Data
                  |L1.1052|
                          DCD      0x40200000
                  |L1.1056|
                          DCD      ||foo||
                  |L1.1060|
                          DCD      ||sha||
                  |L1.1064|
000428  ff0200            DCB      255,2,0
00042b  00                DCB      0
00042c  803f00            DCB      128,"?",0
00042f  00                DCB      0
000430  00                DCB      0
000431  00                DCB      0
000432  00                DCB      0
000433  00                DCB      0
                  |L1.1076|
                          DCD      CryptoKey
                  |L1.1080|
                          DCD      key
                  |L1.1084|
00043c  f104010b          ADD      r1,r4,#0xb
000440  4608              MOV      r0,r1
000442  f7fffffe          BL       AES_cbc_encrypt
                  |L1.1094|
;;;153    			}
;;;154    			/* 加密第二磁道数据 */
;;;155    			if(block2)
000446  b1d7              CBZ      r7,|L1.1150|
;;;156    			{
;;;157    				memset(ivec,0,sizeof(ivec));
000448  2000              MOVS     r0,#0
00044a  9006              STR      r0,[sp,#0x18]
00044c  9007              STR      r0,[sp,#0x1c]
00044e  9008              STR      r0,[sp,#0x20]
000450  9009              STR      r0,[sp,#0x24]
;;;158    				memcpy(ch+11+block1*16,TK2buf+1,block2*16);
000452  013a              LSLS     r2,r7,#4
000454  f104010b          ADD      r1,r4,#0xb
000458  eb011006          ADD      r0,r1,r6,LSL #4
00045c  498f              LDR      r1,|L1.1692|
00045e  f7fffffe          BL       __aeabi_memcpy
;;;159    				AES_cbc_encrypt(ch+11+block1*16,ch+11+block1*16,block2*16,&key,ivec,1);
000462  2001              MOVS     r0,#1
000464  a906              ADD      r1,sp,#0x18
000466  013a              LSLS     r2,r7,#4
000468  f104030b          ADD      r3,r4,#0xb
00046c  e9cd1000          STRD     r1,r0,[sp,#0]
000470  eb031106          ADD      r1,r3,r6,LSL #4
000474  eb031006          ADD      r0,r3,r6,LSL #4
000478  4b89              LDR      r3,|L1.1696|
00047a  f7fffffe          BL       AES_cbc_encrypt
                  |L1.1150|
;;;160    			}
;;;161    			/* 加密第三磁道数据 */
;;;162    			if(block3)
00047e  f1b90f00          CMP      r9,#0
000482  d022              BEQ      |L1.1226|
;;;163    			{
;;;164    				memset(ivec,0,sizeof(ivec));
000484  2000              MOVS     r0,#0
000486  9006              STR      r0,[sp,#0x18]
000488  9007              STR      r0,[sp,#0x1c]
00048a  9008              STR      r0,[sp,#0x20]
00048c  9009              STR      r0,[sp,#0x24]
;;;165    				memcpy(ch+11+(block1+block2)*16,TK3buf+1,block3*16);
00048e  ea4f1209          LSL      r2,r9,#4
000492  19f1              ADDS     r1,r6,r7
000494  f104030b          ADD      r3,r4,#0xb
000498  eb031001          ADD      r0,r3,r1,LSL #4
00049c  4981              LDR      r1,|L1.1700|
00049e  f7fffffe          BL       __aeabi_memcpy
;;;166    				AES_cbc_encrypt(ch+11+(block1+block2)*16,ch+11+(block1+block2)*16,block3*16,&key,ivec,1);
0004a2  2001              MOVS     r0,#1
0004a4  a906              ADD      r1,sp,#0x18
0004a6  ea4f1209          LSL      r2,r9,#4
0004aa  19f3              ADDS     r3,r6,r7
0004ac  f1040c0b          ADD      r12,r4,#0xb
0004b0  e9cd1000          STRD     r1,r0,[sp,#0]
0004b4  eb0c1103          ADD      r1,r12,r3,LSL #4
0004b8  19f3              ADDS     r3,r6,r7
0004ba  eb0c1003          ADD      r0,r12,r3,LSL #4
0004be  4b78              LDR      r3,|L1.1696|
0004c0  f7fffffe          BL       AES_cbc_encrypt
0004c4  e001              B        |L1.1226|
0004c6  e7ff              B        |L1.1224|
                  |L1.1224|
;;;167    			}
;;;168    		}
;;;169    	 	else
;;;170    		{
;;;171    			goto ERRORDATA;
0004c8  e0da              B        |L1.1664|
                  |L1.1226|
;;;172    		}
;;;173    		
;;;174    		if(block3)
0004ca  f1b90f00          CMP      r9,#0
0004ce  d027              BEQ      |L1.1312|
;;;175    		{
;;;176    			memcpy(ch+len-33,sha+40,20);						//保存第三磁道数据哈希值
0004d0  eb040108          ADD      r1,r4,r8
0004d4  f1a10021          SUB      r0,r1,#0x21
0004d8  2214              MOVS     r2,#0x14
0004da  4973              LDR      r1,|L1.1704|
0004dc  f7fffffe          BL       __aeabi_memcpy
;;;177    			if(block2)
0004e0  b19f              CBZ      r7,|L1.1290|
;;;178    			{
;;;179    				memcpy(ch+len-53,sha+20,20);					//保存第二磁道数据哈希值
0004e2  eb040108          ADD      r1,r4,r8
0004e6  f1a10035          SUB      r0,r1,#0x35
0004ea  2214              MOVS     r2,#0x14
0004ec  496e              LDR      r1,|L1.1704|
0004ee  3914              SUBS     r1,r1,#0x14
0004f0  f7fffffe          BL       __aeabi_memcpy
;;;180    				if (block1)
0004f4  b346              CBZ      r6,|L1.1352|
;;;181    					memcpy(ch+len-73,sha,20);   				//保存第一磁道数据哈希值
0004f6  eb040108          ADD      r1,r4,r8
0004fa  f1a10049          SUB      r0,r1,#0x49
0004fe  2214              MOVS     r2,#0x14
000500  4969              LDR      r1,|L1.1704|
000502  3928              SUBS     r1,r1,#0x28
000504  f7fffffe          BL       __aeabi_memcpy
000508  e029              B        |L1.1374|
                  |L1.1290|
;;;182    			}
;;;183    			else if (block1)
00050a  b1ee              CBZ      r6,|L1.1352|
;;;184    				memcpy(ch+len-53,sha,20);   					//保存第一磁道数据哈希值
00050c  eb040108          ADD      r1,r4,r8
000510  f1a10035          SUB      r0,r1,#0x35
000514  2214              MOVS     r2,#0x14
000516  4964              LDR      r1,|L1.1704|
000518  3928              SUBS     r1,r1,#0x28
00051a  f7fffffe          BL       __aeabi_memcpy
00051e  e01e              B        |L1.1374|
                  |L1.1312|
;;;185    		}		 
;;;186    		else
;;;187    		{
;;;188    			if(block2)
000520  b19f              CBZ      r7,|L1.1354|
;;;189    			{
;;;190    				memcpy(ch+len-33,sha+20,20);					//保存第二磁道数据哈希值
000522  eb040108          ADD      r1,r4,r8
000526  f1a10021          SUB      r0,r1,#0x21
00052a  2214              MOVS     r2,#0x14
00052c  495e              LDR      r1,|L1.1704|
00052e  3914              SUBS     r1,r1,#0x14
000530  f7fffffe          BL       __aeabi_memcpy
;;;191    				if (block1)
000534  b146              CBZ      r6,|L1.1352|
;;;192    					memcpy(ch+len-53,sha,20);   				//保存第一磁道数据哈希值
000536  eb040108          ADD      r1,r4,r8
00053a  f1a10035          SUB      r0,r1,#0x35
00053e  2214              MOVS     r2,#0x14
000540  4959              LDR      r1,|L1.1704|
000542  3928              SUBS     r1,r1,#0x28
000544  f7fffffe          BL       __aeabi_memcpy
                  |L1.1352|
000548  e009              B        |L1.1374|
                  |L1.1354|
;;;193    			}
;;;194    			else if (block1)
00054a  b146              CBZ      r6,|L1.1374|
;;;195    				memcpy(ch+len-33,sha,20);   					//保存第一磁道数据哈希值	
00054c  eb040108          ADD      r1,r4,r8
000550  f1a10021          SUB      r0,r1,#0x21
000554  2214              MOVS     r2,#0x14
000556  4954              LDR      r1,|L1.1704|
000558  3928              SUBS     r1,r1,#0x28
00055a  f7fffffe          BL       __aeabi_memcpy
                  |L1.1374|
;;;196    		}
;;;197    				
;;;198    		if((encryptdatastatus & 0x80) == 0x80)
00055e  4853              LDR      r0,|L1.1708|
000560  7800              LDRB     r0,[r0,#0]  ; encryptdatastatus
000562  f0000080          AND      r0,r0,#0x80
000566  2880              CMP      r0,#0x80
000568  d109              BNE      |L1.1406|
;;;199    			memcpy(ch+len-13,ENC_KEY.temp.ksn,10);				//拷贝KSN数据
00056a  eb040008          ADD      r0,r4,r8
00056e  4950              LDR      r1,|L1.1712|
000570  6a4a              LDR      r2,[r1,#0x24]  ; ENC_KEY
000572  f8402d0d          STR      r2,[r0,#-0xd]!
000576  6a8a              LDR      r2,[r1,#0x28]  ; ENC_KEY
000578  6042              STR      r2,[r0,#4]
00057a  8d89              LDRH     r1,[r1,#0x2c]  ; ENC_KEY
00057c  8101              STRH     r1,[r0,#8]
                  |L1.1406|
;;;200    
;;;201    		for(j = 4,lrc = 0,bcc = 0;j<len-3;j++)					//计算校验码
00057e  2504              MOVS     r5,#4
000580  f04f0a00          MOV      r10,#0
000584  f04f0b00          MOV      r11,#0
000588  e008              B        |L1.1436|
                  |L1.1418|
;;;202    		{
;;;203    			lrc ^= ch[j];
00058a  5d60              LDRB     r0,[r4,r5]
00058c  ea800a0a          EOR      r10,r0,r10
;;;204    			bcc += ch[j];
000590  5d60              LDRB     r0,[r4,r5]
000592  4458              ADD      r0,r0,r11
000594  f0000bff          AND      r11,r0,#0xff
000598  1c68              ADDS     r0,r5,#1              ;201
00059a  b285              UXTH     r5,r0                 ;201
                  |L1.1436|
00059c  f1a80003          SUB      r0,r8,#3              ;201
0005a0  42a8              CMP      r0,r5                 ;201
0005a2  dcf2              BGT      |L1.1418|
;;;205    		}
;;;206    		ch[len-3] = lrc;
0005a4  f804a000          STRB     r10,[r4,r0]
;;;207    		ch[len-2] = bcc;
0005a8  1c40              ADDS     r0,r0,#1
0005aa  f804b000          STRB     r11,[r4,r0]
;;;208    		ch[len-1] = 0x03;
0005ae  2103              MOVS     r1,#3
0005b0  1c40              ADDS     r0,r0,#1
0005b2  5421              STRB     r1,[r4,r0]
0005b4  e06b              B        |L1.1678|
                  |L1.1462|
;;;209    	}
;;;210    	else if(0 == ENC_KEY.temp.status)			  					//明文回送数据
0005b6  483e              LDR      r0,|L1.1712|
0005b8  7800              LDRB     r0,[r0,#0]  ; ENC_KEY
0005ba  bbe8              CBNZ     r0,|L1.1592|
;;;211    	{
;;;212    		len = 1+TK3len+TK2len+TK1len;
0005bc  4839              LDR      r0,|L1.1700|
0005be  1e40              SUBS     r0,r0,#1
0005c0  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
0005c4  1c40              ADDS     r0,r0,#1
0005c6  4935              LDR      r1,|L1.1692|
0005c8  1e49              SUBS     r1,r1,#1
0005ca  f891106e          LDRB     r1,[r1,#0x6e]  ; Track2Data
0005ce  4408              ADD      r0,r0,r1
0005d0  4938              LDR      r1,|L1.1716|
0005d2  f891106e          LDRB     r1,[r1,#0x6e]  ; Track1Data
0005d6  eb000801          ADD      r8,r0,r1
;;;213    		ch[0]=0xFF;
0005da  20ff              MOVS     r0,#0xff
0005dc  7020              STRB     r0,[r4,#0]
;;;214    		if(TK3len)TK3buf[TK3len-1] = 0x0D;
0005de  4831              LDR      r0,|L1.1700|
0005e0  1e40              SUBS     r0,r0,#1
0005e2  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
0005e6  b140              CBZ      r0,|L1.1530|
0005e8  210d              MOVS     r1,#0xd
0005ea  482e              LDR      r0,|L1.1700|
0005ec  1e40              SUBS     r0,r0,#1
0005ee  f890006e          LDRB     r0,[r0,#0x6e]  ; Track3Data
0005f2  1e40              SUBS     r0,r0,#1
0005f4  4a2b              LDR      r2,|L1.1700|
0005f6  1e52              SUBS     r2,r2,#1
0005f8  5411              STRB     r1,[r2,r0]
                  |L1.1530|
;;;215    		if(TK2len)TK2buf[TK2len-1] = 0x0D;
0005fa  4828              LDR      r0,|L1.1692|
0005fc  1e40              SUBS     r0,r0,#1
0005fe  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
000602  b140              CBZ      r0,|L1.1558|
000604  210d              MOVS     r1,#0xd
000606  4825              LDR      r0,|L1.1692|
000608  1e40              SUBS     r0,r0,#1
00060a  f890006e          LDRB     r0,[r0,#0x6e]  ; Track2Data
00060e  1e40              SUBS     r0,r0,#1
000610  4a22              LDR      r2,|L1.1692|
000612  1e52              SUBS     r2,r2,#1
000614  5411              STRB     r1,[r2,r0]
                  |L1.1558|
;;;216    		if(TK1len)TK1buf[TK1len-1] = 0x0D;
000616  4827              LDR      r0,|L1.1716|
000618  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
00061c  b130              CBZ      r0,|L1.1580|
00061e  210d              MOVS     r1,#0xd
000620  4824              LDR      r0,|L1.1716|
000622  f890006e          LDRB     r0,[r0,#0x6e]  ; Track1Data
000626  1e40              SUBS     r0,r0,#1
000628  4a22              LDR      r2,|L1.1716|
00062a  5411              STRB     r1,[r2,r0]
                  |L1.1580|
;;;217    		memcpy(ch+1,TK3buf,TK3len);
00062c  481d              LDR      r0,|L1.1700|
00062e  1e40              SUBS     r0,r0,#1
000630  f890206e          LDRB     r2,[r0,#0x6e]  ; Track3Data
000634  4601              MOV      r1,r0
000636  e000              B        |L1.1594|
                  |L1.1592|
000638  e021              B        |L1.1662|
                  |L1.1594|
00063a  1c60              ADDS     r0,r4,#1
00063c  f7fffffe          BL       __aeabi_memcpy
;;;218    		memcpy(ch+1+TK3len,TK2buf,TK2len);
000640  4916              LDR      r1,|L1.1692|
000642  1e49              SUBS     r1,r1,#1
000644  f891206e          LDRB     r2,[r1,#0x6e]  ; Track2Data
000648  4916              LDR      r1,|L1.1700|
00064a  1e49              SUBS     r1,r1,#1
00064c  f891306e          LDRB     r3,[r1,#0x6e]  ; Track3Data
000650  1c61              ADDS     r1,r4,#1
000652  1858              ADDS     r0,r3,r1
000654  4911              LDR      r1,|L1.1692|
000656  1e49              SUBS     r1,r1,#1
000658  f7fffffe          BL       __aeabi_memcpy
;;;219    		memcpy(ch+1+TK3len+TK2len,TK1buf,TK1len);
00065c  4911              LDR      r1,|L1.1700|
00065e  1e49              SUBS     r1,r1,#1
000660  f891306e          LDRB     r3,[r1,#0x6e]  ; Track3Data
000664  1c61              ADDS     r1,r4,#1
000666  4419              ADD      r1,r1,r3
000668  4b0c              LDR      r3,|L1.1692|
00066a  1e5b              SUBS     r3,r3,#1
00066c  f893306e          LDRB     r3,[r3,#0x6e]  ; Track2Data
000670  18c8              ADDS     r0,r1,r3
000672  4910              LDR      r1,|L1.1716|
000674  f891206e          LDRB     r2,[r1,#0x6e]  ; Track1Data
000678  f7fffffe          BL       __aeabi_memcpy
00067c  e007              B        |L1.1678|
                  |L1.1662|
;;;220    	}
;;;221    	else
;;;222    	{
;;;223    ERRORDATA:
00067e  bf00              NOP      
                  |L1.1664|
;;;224    		len = 10;
000680  f04f080a          MOV      r8,#0xa
;;;225    		memset(ch, 0xFF, len);					
000684  22ff              MOVS     r2,#0xff
000686  4641              MOV      r1,r8
000688  4620              MOV      r0,r4
00068a  f7fffffe          BL       __aeabi_memset
                  |L1.1678|
;;;226    	}
;;;227    	
;;;228    	dev_com_write(ch, len);
00068e  4641              MOV      r1,r8
000690  4620              MOV      r0,r4
000692  f7fffffe          BL       dev_com_write
;;;229    	
;;;230    	return;
;;;231    }
000696  b00b              ADD      sp,sp,#0x2c
000698  e8bd8ff0          POP      {r4-r11,pc}
;;;232    
                          ENDP

                  |L1.1692|
                          DCD      Track2Data+0x1
                  |L1.1696|
                          DCD      key
                  |L1.1700|
                          DCD      Track3Data+0x1
                  |L1.1704|
                          DCD      ||sha||+0x28
                  |L1.1708|
                          DCD      encryptdatastatus
                  |L1.1712|
                          DCD      ENC_KEY
                  |L1.1716|
                          DCD      Track1Data

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  ||foo||
                          %        96
                  key
                          %        244
                  ||sha||
                          %        60

                          AREA ||.data||, DATA, ALIGN=0

                  base64digits
000000  41424344          DCB      0x41,0x42,0x43,0x44
000004  45464748          DCB      0x45,0x46,0x47,0x48
000008  494a4b4c          DCB      0x49,0x4a,0x4b,0x4c
00000c  4d4e4f50          DCB      0x4d,0x4e,0x4f,0x50
000010  51525354          DCB      0x51,0x52,0x53,0x54
000014  55565758          DCB      0x55,0x56,0x57,0x58
000018  595a6162          DCB      0x59,0x5a,0x61,0x62
00001c  63646566          DCB      0x63,0x64,0x65,0x66
000020  6768696a          DCB      0x67,0x68,0x69,0x6a
000024  6b6c6d6e          DCB      0x6b,0x6c,0x6d,0x6e
000028  6f707172          DCB      0x6f,0x70,0x71,0x72
00002c  73747576          DCB      0x73,0x74,0x75,0x76
000030  7778797a          DCB      0x77,0x78,0x79,0x7a
000034  30313233          DCB      0x30,0x31,0x32,0x33
000038  34353637          DCB      0x34,0x35,0x36,0x37
00003c  38392b2f          DCB      0x38,0x39,0x2b,0x2f
000040  00                DCB      0x00
                  base64val
000041  ffffff            DCB      0xff,0xff,0xff
000044  ffffffff          DCB      0xff,0xff,0xff,0xff
000048  ffffffff          DCB      0xff,0xff,0xff,0xff
00004c  ffffffff          DCB      0xff,0xff,0xff,0xff
000050  ffffffff          DCB      0xff,0xff,0xff,0xff
000054  ffffffff          DCB      0xff,0xff,0xff,0xff
000058  ffffffff          DCB      0xff,0xff,0xff,0xff
00005c  ffffffff          DCB      0xff,0xff,0xff,0xff
000060  ffffffff          DCB      0xff,0xff,0xff,0xff
000064  ffffffff          DCB      0xff,0xff,0xff,0xff
000068  ffffffff          DCB      0xff,0xff,0xff,0xff
00006c  3effffff          DCB      0x3e,0xff,0xff,0xff
000070  3f343536          DCB      0x3f,0x34,0x35,0x36
000074  3738393a          DCB      0x37,0x38,0x39,0x3a
000078  3b3c3dff          DCB      0x3b,0x3c,0x3d,0xff
00007c  ffffffff          DCB      0xff,0xff,0xff,0xff
000080  ffff0001          DCB      0xff,0xff,0x00,0x01
000084  02030405          DCB      0x02,0x03,0x04,0x05
000088  06070809          DCB      0x06,0x07,0x08,0x09
00008c  0a0b0c0d          DCB      0x0a,0x0b,0x0c,0x0d
000090  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000094  12131415          DCB      0x12,0x13,0x14,0x15
000098  16171819          DCB      0x16,0x17,0x18,0x19
00009c  ffffffff          DCB      0xff,0xff,0xff,0xff
0000a0  ffff1a1b          DCB      0xff,0xff,0x1a,0x1b
0000a4  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
0000a8  20212223          DCB      0x20,0x21,0x22,0x23
0000ac  24252627          DCB      0x24,0x25,0x26,0x27
0000b0  28292a2b          DCB      0x28,0x29,0x2a,0x2b
0000b4  2c2d2e2f          DCB      0x2c,0x2d,0x2e,0x2f
0000b8  30313233          DCB      0x30,0x31,0x32,0x33
0000bc  ffffffff          DCB      0xff,0xff,0xff,0xff
0000c0  ff                DCB      0xff

;*** Start embedded assembler ***

#line 1 "..\\dev\\dev_msread.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_dev_msread_c_54a1b807____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_dev_msread_c_54a1b807____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_dev_msread_c_54a1b807____REVSH|
#line 144
|__asm___12_dev_msread_c_54a1b807____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
