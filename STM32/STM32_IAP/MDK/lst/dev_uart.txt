; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dev_uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dev_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\user -I..\dev -I..\lib\inc -I..\core_cm3 -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\dev_uart.crf ..\dev\dev_uart.c]
                          THUMB

                          AREA ||i.dev_com_close||, CODE, READONLY, ALIGN=2

                  dev_com_close PROC
;;;122    ******************************************************************/
;;;123    int dev_com_close(void)
000000  b508              PUSH     {r3,lr}
;;;124    {
;;;125    	GPIO_InitTypeDef GPIO_InitStructure;
;;;126    
;;;127    	// TXD && RXD Reset
;;;128    	GPIO_InitStructure.GPIO_Pin = PinTXD1 | PinRXD1;
000002  f44f60c0          MOV      r0,#0x600
000006  f8ad0000          STRH     r0,[sp,#0]
;;;129    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;130    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000010  4669              MOV      r1,sp
000012  4809              LDR      r0,|L1.56|
000014  f7fffffe          BL       GPIO_Init
;;;131    
;;;132    	USART_Cmd(USART1, DISABLE);
000018  2100              MOVS     r1,#0
00001a  4808              LDR      r0,|L1.60|
00001c  f7fffffe          BL       USART_Cmd
;;;133    	RCC_APB1PeriphClockCmd(RCC_APB2Periph_USART1, DISABLE);
000020  2100              MOVS     r1,#0
000022  f44f4080          MOV      r0,#0x4000
000026  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;134    	
;;;135    	rec_end0 = rec_head0 = 0;
00002a  2000              MOVS     r0,#0
00002c  4904              LDR      r1,|L1.64|
00002e  8008              STRH     r0,[r1,#0]
000030  4904              LDR      r1,|L1.68|
000032  8008              STRH     r0,[r1,#0]
;;;136    	return(0); 	
;;;137    }
000034  bd08              POP      {r3,pc}
;;;138    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40010800
                  |L1.60|
                          DCD      0x40013800
                  |L1.64|
                          DCD      rec_head0
                  |L1.68|
                          DCD      rec_end0

                          AREA ||i.dev_com_open||, CODE, READONLY, ALIGN=2

                  dev_com_open PROC
;;;59     ******************************************************************/
;;;60     int dev_com_open(void)
000000  b500              PUSH     {lr}
;;;61     {
000002  b087              SUB      sp,sp,#0x1c
;;;62     	// 默认波特率为：115200
;;;63     	GPIO_InitTypeDef GPIO_InitStructure;
;;;64     	USART_InitTypeDef USART_InitStructure;
;;;65     	NVIC_InitTypeDef NVIC_InitStructure;
;;;66     
;;;67     	// 复位串口模块
;;;68     	USART_DeInit(USART1);
000004  482a              LDR      r0,|L2.176|
000006  f7fffffe          BL       USART_DeInit
;;;69     	
;;;70     	// 打开GPIO电源
;;;71     	RCC_APB2PeriphClockCmd (RCC_APB2Periph_GPIOA |
00000a  2101              MOVS     r1,#1
00000c  f2440005          MOV      r0,#0x4005
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;72     								RCC_APB2Periph_AFIO |
;;;73     								RCC_APB2Periph_USART1	//TXD/RXD1
;;;74     								,
;;;75     								ENABLE);
;;;76     	
;;;77     	// 打开串口时钟
;;;78     	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;79     
;;;80     	// TXD，管脚PA2
;;;81     	GPIO_InitStructure.GPIO_Pin = PinTXD1;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0018          STRH     r0,[sp,#0x18]
;;;82         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d001a          STRB     r0,[sp,#0x1a]
;;;83         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d001b          STRB     r0,[sp,#0x1b]
;;;84         GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a906              ADD      r1,sp,#0x18
00002a  4822              LDR      r0,|L2.180|
00002c  f7fffffe          BL       GPIO_Init
;;;85     	// RXD，管脚PA3
;;;86     	GPIO_InitStructure.GPIO_Pin = PinRXD1;    
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0018          STRH     r0,[sp,#0x18]
;;;87         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d001b          STRB     r0,[sp,#0x1b]
;;;88         GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a906              ADD      r1,sp,#0x18
000040  481c              LDR      r0,|L2.180|
000042  f7fffffe          BL       GPIO_Init
;;;89     	
;;;90     	/* Enable the USART2 Interrupt */
;;;91     	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000046  2025              MOVS     r0,#0x25
000048  f88d0004          STRB     r0,[sp,#4]
;;;92     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00004c  2001              MOVS     r0,#1
00004e  f88d0005          STRB     r0,[sp,#5]
;;;93     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000052  2000              MOVS     r0,#0
000054  f88d0006          STRB     r0,[sp,#6]
;;;94     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000058  2001              MOVS     r0,#1
00005a  f88d0007          STRB     r0,[sp,#7]
;;;95     	NVIC_Init(&NVIC_InitStructure);
00005e  a801              ADD      r0,sp,#4
000060  f7fffffe          BL       NVIC_Init
;;;96     	
;;;97     	USART_InitStructure.USART_BaudRate = 115200;
000064  f44f30e1          MOV      r0,#0x1c200
000068  9002              STR      r0,[sp,#8]
;;;98     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00006a  2000              MOVS     r0,#0
00006c  f8ad000c          STRH     r0,[sp,#0xc]
;;;99     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000070  f8ad000e          STRH     r0,[sp,#0xe]
;;;100    	USART_InitStructure.USART_Parity = USART_Parity_No;
000074  f8ad0010          STRH     r0,[sp,#0x10]
;;;101    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000078  200c              MOVS     r0,#0xc
00007a  f8ad0012          STRH     r0,[sp,#0x12]
;;;102    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00007e  2000              MOVS     r0,#0
000080  f8ad0014          STRH     r0,[sp,#0x14]
;;;103    	USART_Init(USART1, &USART_InitStructure); 
000084  a902              ADD      r1,sp,#8
000086  480a              LDR      r0,|L2.176|
000088  f7fffffe          BL       USART_Init
;;;104    	
;;;105    	// 打开串口接收中断
;;;106    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00008c  2201              MOVS     r2,#1
00008e  f2405125          MOV      r1,#0x525
000092  4807              LDR      r0,|L2.176|
000094  f7fffffe          BL       USART_ITConfig
;;;107    	USART_Cmd(USART1, ENABLE);
000098  2101              MOVS     r1,#1
00009a  4805              LDR      r0,|L2.176|
00009c  f7fffffe          BL       USART_Cmd
;;;108    
;;;109    	rec_end0 = rec_head0 = 0;
0000a0  2000              MOVS     r0,#0
0000a2  4905              LDR      r1,|L2.184|
0000a4  8008              STRH     r0,[r1,#0]
0000a6  4905              LDR      r1,|L2.188|
0000a8  8008              STRH     r0,[r1,#0]
;;;110    
;;;111    	return (0);
;;;112    }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bd00              POP      {pc}
;;;113    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      0x40013800
                  |L2.180|
                          DCD      0x40010800
                  |L2.184|
                          DCD      rec_head0
                  |L2.188|
                          DCD      rec_end0

                          AREA ||i.dev_com_read||, CODE, READONLY, ALIGN=2

                  dev_com_read PROC
;;;148    ********************************************************************/
;;;149    int dev_com_read(unsigned char *buf, int len)
000000  b530              PUSH     {r4,r5,lr}
;;;150    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;151    	int i;
;;;152    
;;;153    	if(len <= 0 || buf == NULL)
000006  2b00              CMP      r3,#0
000008  dd00              BLE      |L3.12|
00000a  b912              CBNZ     r2,|L3.18|
                  |L3.12|
;;;154    		return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L3.16|
;;;155    	
;;;156    	i = 0;
;;;157    	while (rec_head0 != rec_end0) {
;;;158    		*buf = rec_buf0[rec_head0++];
;;;159    		if(rec_head0 >= RXTEMPBUFLENMAX)
;;;160    			rec_head0 = 0;
;;;161    		buf++;
;;;162    		i++;
;;;163    
;;;164    		if(i >= len) {
;;;165    			break;
;;;166    		}
;;;167    	}
;;;168    	return (i);
;;;169    }
000010  bd30              POP      {r4,r5,pc}
                  |L3.18|
000012  2100              MOVS     r1,#0                 ;156
000014  e014              B        |L3.64|
                  |L3.22|
000016  4c0f              LDR      r4,|L3.84|
000018  8820              LDRH     r0,[r4,#0]            ;158  ; rec_head0
00001a  1c44              ADDS     r4,r0,#1              ;158
00001c  4d0d              LDR      r5,|L3.84|
00001e  802c              STRH     r4,[r5,#0]            ;158
000020  4c0d              LDR      r4,|L3.88|
000022  5c24              LDRB     r4,[r4,r0]            ;158
000024  7014              STRB     r4,[r2,#0]            ;158
000026  4628              MOV      r0,r5                 ;159
000028  8800              LDRH     r0,[r0,#0]            ;159  ; rec_head0
00002a  f5b07f00          CMP      r0,#0x200             ;159
00002e  db02              BLT      |L3.54|
000030  2000              MOVS     r0,#0                 ;160
000032  462c              MOV      r4,r5                 ;160
000034  8020              STRH     r0,[r4,#0]            ;160
                  |L3.54|
000036  1c52              ADDS     r2,r2,#1              ;161
000038  1c49              ADDS     r1,r1,#1              ;162
00003a  4299              CMP      r1,r3                 ;164
00003c  db00              BLT      |L3.64|
00003e  e005              B        |L3.76|
                  |L3.64|
000040  4804              LDR      r0,|L3.84|
000042  8800              LDRH     r0,[r0,#0]            ;157  ; rec_head0
000044  4c05              LDR      r4,|L3.92|
000046  8824              LDRH     r4,[r4,#0]            ;157  ; rec_end0
000048  42a0              CMP      r0,r4                 ;157
00004a  d1e4              BNE      |L3.22|
                  |L3.76|
00004c  bf00              NOP                            ;165
00004e  4608              MOV      r0,r1                 ;168
000050  e7de              B        |L3.16|
;;;170    
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      rec_head0
                  |L3.88|
                          DCD      Track1TimeFlow
                  |L3.92|
                          DCD      rec_end0

                          AREA ||i.dev_com_write||, CODE, READONLY, ALIGN=2

                  dev_com_write PROC
;;;179    ********************************************************************/
;;;180    int dev_com_write(unsigned char *buf, int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;181    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;182    	unsigned int t, i;
;;;183    
;;;184    	if (buf == NULL || len <= 0) 
000008  b10e              CBZ      r6,|L4.14|
00000a  2c00              CMP      r4,#0
00000c  dc03              BGT      |L4.22|
                  |L4.14|
;;;185    		return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L4.18|
;;;186    	i = 0;
;;;187    	while (len != 0) {
;;;188    		// 等待串口发送完毕
;;;189    		t = 0;
;;;190    		while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET) {
;;;191    			if (t++ >= 0x100000)	//超时
;;;192    				return i;
;;;193    		}
;;;194    		USART_SendData(USART1, buf[i]);
;;;195    		i++;
;;;196    		len--;
;;;197    	}
;;;198    	return i;
;;;199    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L4.22|
000016  2500              MOVS     r5,#0                 ;186
000018  e014              B        |L4.68|
                  |L4.26|
00001a  2700              MOVS     r7,#0                 ;189
00001c  e006              B        |L4.44|
                  |L4.30|
00001e  4638              MOV      r0,r7                 ;191
000020  1c7f              ADDS     r7,r7,#1              ;191
000022  f5b01f80          CMP      r0,#0x100000          ;191
000026  d301              BCC      |L4.44|
000028  4628              MOV      r0,r5                 ;192
00002a  e7f2              B        |L4.18|
                  |L4.44|
00002c  2180              MOVS     r1,#0x80              ;190
00002e  4807              LDR      r0,|L4.76|
000030  f7fffffe          BL       USART_GetFlagStatus
000034  2800              CMP      r0,#0                 ;190
000036  d0f2              BEQ      |L4.30|
000038  5d71              LDRB     r1,[r6,r5]            ;194
00003a  4804              LDR      r0,|L4.76|
00003c  f7fffffe          BL       USART_SendData
000040  1c6d              ADDS     r5,r5,#1              ;195
000042  1e64              SUBS     r4,r4,#1              ;196
                  |L4.68|
000044  2c00              CMP      r4,#0                 ;187
000046  d1e8              BNE      |L4.26|
000048  4628              MOV      r0,r5                 ;198
00004a  e7e2              B        |L4.18|
;;;200    
                          ENDP

                  |L4.76|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;23     
;;;24     PUTCHAR_PROTOTYPE
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;26     	/* Place your implementation of fputc here */
;;;27     	/* e.g. write a character to the USART */
;;;28     	USART_SendData(USART1, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L5.32|
00000a  f7fffffe          BL       USART_SendData
;;;29     
;;;30     	/* Loop until the end of transmission */
;;;31     	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
00000e  bf00              NOP      
                  |L5.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L5.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L5.16|
;;;32     	return ch;
00001c  4620              MOV      r0,r4
;;;33     }
00001e  bd70              POP      {r4-r6,pc}
;;;34     
                          ENDP

                  |L5.32|
                          DCD      0x40013800

                          AREA ||i.uart_printf||, CODE, READONLY, ALIGN=1

                  uart_printf PROC
;;;200    
;;;201    void uart_printf(char *fmt,...)
000000  b40f              PUSH     {r0-r3}
;;;202    {
000002  b530              PUSH     {r4,r5,lr}
000004  b0c1              SUB      sp,sp,#0x104
;;;203        int length = 0;
000006  2500              MOVS     r5,#0
;;;204        va_list ap;
;;;205        char string[256];
;;;206        char *pt;
;;;207        va_start(ap,fmt);
000008  a845              ADD      r0,sp,#0x114
00000a  9040              STR      r0,[sp,#0x100]
;;;208        vsprintf((char *)string,(const char *)fmt,ap);
00000c  4668              MOV      r0,sp
00000e  9a40              LDR      r2,[sp,#0x100]
000010  9944              LDR      r1,[sp,#0x110]
000012  f7fffffe          BL       __c89vsprintf
;;;209        pt = &string[0];
000016  466c              MOV      r4,sp
;;;210        while(*pt!='\0')
000018  e001              B        |L6.30|
                  |L6.26|
;;;211        {
;;;212            length++;
00001a  1c6d              ADDS     r5,r5,#1
;;;213            pt++;
00001c  1c64              ADDS     r4,r4,#1
                  |L6.30|
00001e  7820              LDRB     r0,[r4,#0]            ;210
000020  2800              CMP      r0,#0                 ;210
000022  d1fa              BNE      |L6.26|
;;;214        }
;;;215        dev_com_write((unsigned char *)string, length);  //写串口成功
000024  4629              MOV      r1,r5
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       dev_com_write
;;;216        va_end(ap);
00002c  2000              MOVS     r0,#0
00002e  9040              STR      r0,[sp,#0x100]
;;;217    }
000030  b041              ADD      sp,sp,#0x104
000032  bc30              POP      {r4,r5}
000034  f85dfb14          LDR      pc,[sp],#0x14
                          ENDP


                          AREA ||i.uart_puts||, CODE, READONLY, ALIGN=1

                  uart_puts PROC
;;;43     ******************************************************************/
;;;44     void uart_puts(char *s)
000000  b510              PUSH     {r4,lr}
;;;45     {
000002  4604              MOV      r4,r0
;;;46       while (*s != '\0') {
000004  e004              B        |L7.16|
                  |L7.6|
;;;47     	dev_com_write((unsigned char *)s, 1);
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dev_com_write
;;;48         s++;
00000e  1c64              ADDS     r4,r4,#1
                  |L7.16|
000010  7820              LDRB     r0,[r4,#0]            ;46
000012  2800              CMP      r0,#0                 ;46
000014  d1f7              BNE      |L7.6|
;;;49       }
;;;50     }
000016  bd10              POP      {r4,pc}
;;;51     /******************************************************************
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  rec_head0
000000  0000              DCB      0x00,0x00
                  rec_end0
000002  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\dev\\dev_uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_dev_uart_c_fputc____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_dev_uart_c_fputc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_dev_uart_c_fputc____REVSH|
#line 144
|__asm___10_dev_uart_c_fputc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
